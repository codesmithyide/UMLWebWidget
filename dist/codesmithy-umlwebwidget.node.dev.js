(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CodeSmithyUMLWebWidget"] = factory();
	else
		root["CodeSmithyUMLWebWidget"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Actor.js":
/*!**********************!*\
  !*** ./src/Actor.js ***!
  \**********************/
/*! exports provided: Actor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Actor\", function() { return Actor; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n  An actor on a use case diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Actor extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, actorDescription) {\r\n        super(svg, \"actor\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.actorDescription = actorDescription\r\n        this.connectionPointsRectangle = null\r\n    }\r\n\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPoint\"](svg, this)\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        let borderAdjustment = {\r\n            top: this.y,\r\n            left: this.x\r\n        }\r\n        \r\n        let shapeGroup = this.shapeLayer.group().addClass(\"UMLActor\")\r\n        let textGroup = this.textLayer.group()\r\n        let textDef = textGroup.text(this.actorDescription.name).move(borderAdjustment.left, borderAdjustment.top + 35)\r\n        let width = textDef.bbox().width\r\n        let offset = ((width - 16) / 2)\r\n        shapeGroup.circle(12).move(borderAdjustment.left + 2 + offset, borderAdjustment.top + 1)\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 13, borderAdjustment.left + 8 + offset, borderAdjustment.top + 26)\r\n        shapeGroup.line(borderAdjustment.left + offset, borderAdjustment.top + 18, borderAdjustment.left + 16 + offset, borderAdjustment.top + 18)\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 26, borderAdjustment.left + offset, borderAdjustment.top + 33)\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 26, borderAdjustment.left + 16 + offset, borderAdjustment.top + 33)\r\n\r\n        this.connectionPointsRectangle = {\r\n            \"x\": borderAdjustment.left,\r\n            \"y\": borderAdjustment.top,\r\n            \"w\": width,\r\n            \"width\": width,\r\n            \"height\": (35 + textDef.bbox().height),\r\n            \"h\": (35 + textDef.bbox().height),\r\n            \"x2\": (borderAdjustment.left + width),\r\n            \"y2\": (borderAdjustment.top + 35 + textDef.bbox().height),\r\n            \"cx\": (borderAdjustment.left + (width / 2)),\r\n            \"cy\": (borderAdjustment.top + ((35 + textDef.bbox().height) / 2))\r\n        }\r\n    }\r\n\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle \r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Actor.js?");

/***/ }),

/***/ "./src/BallConnector.js":
/*!******************************!*\
  !*** ./src/BallConnector.js ***!
  \******************************/
/*! exports provided: BallConnector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BallConnector\", function() { return BallConnector; });\n/* harmony import */ var _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGLayerSet.js */ \"./src/SVGLayerSet.js\");\n\r\n\r\n\r\n\r\nvar textDef = Symbol()\r\n\r\n/**\r\n  A ball connector to represent an interface for a\r\n  component.\r\n*/\r\nclass BallConnector {\r\n\r\n    constructor(svg, component, name) {\r\n        this.svg = svg\r\n        this.layers = new _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__[\"SVGLayerSet\"](svg)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.uptodate = false\r\n        this.x = 0\r\n        this.y = 0\r\n        this.component = component\r\n        this.name = name\r\n        this.textGroup = this.textLayer.group()\r\n        this[textDef] = this.textGroup.text(this.name).move(0, 0) \r\n        this.width = this[textDef].bbox().width + 5\r\n    }\r\n\r\n    getLayers() {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        return this.layers\r\n    }\r\n\r\n    // Move the connector so that the top left\r\n    // corner of the bounding box is at position\r\n    // (x, y)\r\n    move(x, y) {\r\n        this.uptodate = false\r\n        this.x = x\r\n        this.y = y\r\n    }\r\n\r\n    // Move the connector so that its connection\r\n    // point is at position (x, y)\r\n    moveConnectionPoint(x, y) {\r\n        this.uptodate = false\r\n        let connectorOffsetY = this[textDef].bbox().height + 3\r\n        y -= connectorOffsetY\r\n        this.move(x, y)\r\n    }\r\n\r\n    update() {\r\n        this.shapeLayer.clear()\r\n        this[textDef].move(this.x, this.y)\r\n        let lineGroup = this.shapeLayer.group().addClass(\"UMLComponent\")\r\n        lineGroup.circle(10).move(this.x + (this.width)/2 - 5, this.y + 22)\r\n        lineGroup.line(this.x + 10 + (this.width)/2 - 5, this.y + 27, this.x + (this.width), this.y + 27)\r\n    }\r\n\r\n    getAssemblyConnectionPoint() {\r\n        return { x: (this.x + (this.width / 2) - 4), y: this.y + this[textDef].bbox().height + 5 }\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/BallConnector.js?");

/***/ }),

/***/ "./src/ClassBox.js":
/*!*************************!*\
  !*** ./src/ClassBox.js ***!
  \*************************/
/*! exports provided: ClassBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassBox\", function() { return ClassBox; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SVGLayerSet.js */ \"./src/SVGLayerSet.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n/* harmony import */ var _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawingUtilities.js */ \"./src/DrawingUtilities.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** \r\n  A class box. \r\n\r\n  @extends DiagramElement\r\n  @property {ConnectionPoint[]} this.connectionPoints - The class\r\n    keeps a list of connection points where other elements are \r\n    connected so they can be notified of relevant changes to the\r\n    class box.\r\n*/\r\nclass ClassBox extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, classDescription, canMove, style) {\r\n        super(svg, \"class\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.classDescription = classDescription\r\n        this.canMove = canMove\r\n        this.style = style\r\n        this.connectionPointsRectangle = null\r\n\r\n        // List of connection points that are connected to\r\n        // this class box\r\n        this.connectionPoints = [ ]\r\n    }\r\n\r\n    /**\r\n      Returns a connection point that can be used to connect\r\n      a connector to this class box. The new connection\r\n      point is added to this.connectionPoints.\r\n    */\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_2__[\"ConnectionPoint\"](svg, this)\r\n        this.connectionPoints.push(newPoint)\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        createDef(this, this.classDescription, this.canMove, this.style)\r\n    }\r\n\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle \r\n    }\r\n        \r\n    fire(evt) {\r\n        if (evt == \"positionchanged\") {\r\n            for (let i = 0; i < this.connectionPoints.length; i++) {\r\n                this.connectionPoints[i].draw()        \r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction createDef(self, classInfo, canMove, style) {\r\n    var classGroup = self.shapeLayer.group().addClass(\"UMLClassBox\")\r\n\r\n    let currentDimensions = { \r\n        width: 0,\r\n        height: 0\r\n    }\r\n\r\n    let borderAdjustment = {\r\n        top: self.y + 1,\r\n        left: self.x + 1\r\n    }\r\n    \r\n    currentDimensions.height = style.getTopMargin(\"classbox\")\r\n\r\n    var classNameGroup = self.textLayer.group().addClass(\"UMLClassName\")\r\n    var className = classNameGroup.text(classInfo.name).move(borderAdjustment.left + style.getLeftMargin(\"classbox\"), borderAdjustment.top + currentDimensions.height)\r\n    currentDimensions.width = Math.max(currentDimensions.width, className.bbox().width)\r\n    currentDimensions.height += (className.bbox().height + style.getBottomMargin(\"classbox\"))\r\n\r\n    var line1YPos = (borderAdjustment.top + currentDimensions.height)\r\n\r\n    let attributesCompartmentDimensions = _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_3__[\"DrawingUtilities\"].addClassCompartmentText(borderAdjustment.left, line1YPos, self.textLayer, style, classInfo.attributes, \"UMLClassAttributes\")\r\n    currentDimensions.width = Math.max(currentDimensions.width, attributesCompartmentDimensions.width)\r\n    currentDimensions.height += attributesCompartmentDimensions.height\r\n\r\n    var line2YPos = (borderAdjustment.top + currentDimensions.height)\r\n\r\n    let operationsCompartmentDimensions = _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_3__[\"DrawingUtilities\"].addClassCompartmentText(borderAdjustment.left, line2YPos, self.textLayer, style, classInfo.operations, \"UMLClassOperations\")\r\n    currentDimensions.width = Math.max(currentDimensions.width, operationsCompartmentDimensions.width)\r\n    currentDimensions.height += operationsCompartmentDimensions.height\r\n\r\n    // According to the UML standard the class name must be\r\n    // centered so center it\r\n    if (currentDimensions.width > className.bbox().width) {\r\n        className.dx((currentDimensions.width - className.bbox().width)/2)\r\n    }\r\n\r\n    currentDimensions.width += (style.getLeftMargin(\"classbox\") + style.getRightMargin(\"classbox\"))\r\n    \r\n    let rect = classGroup.rect(currentDimensions.width, currentDimensions.height).move(borderAdjustment.left, borderAdjustment.top)\r\n    classGroup.line(borderAdjustment.left, line1YPos, borderAdjustment.left + currentDimensions.width, line1YPos)\r\n    classGroup.line(borderAdjustment.left, line2YPos, borderAdjustment.left + currentDimensions.width, line2YPos)\r\n\r\n    self.connectionPointsRectangle = rect.bbox()\r\n\r\n    if (canMove) {\r\n        classGroup.draggable(true)\r\n        classGroup.on('dragmove.namespace', function(evt) {\r\n            self.fire('positionchanged')\r\n        })\r\n        classGroup.on('dragend.namespace', function(evt) {\r\n            self.fire('positionchanged')\r\n        })\r\n    }\r\n\r\n    return classGroup\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ClassBox.js?");

/***/ }),

/***/ "./src/ClassTemplate.js":
/*!******************************!*\
  !*** ./src/ClassTemplate.js ***!
  \******************************/
/*! exports provided: ClassTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassTemplate\", function() { return ClassTemplate; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n/* harmony import */ var _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawingUtilities.js */ \"./src/DrawingUtilities.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass ClassTemplate extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, classTemplateDescription, style) {\r\n        super(svg, \"classtemplate\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.classTemplateDescription = classTemplateDescription\r\n        this.style = style\r\n        this.connectionPointsRectangle = null\r\n\r\n        // List of connection points that are connected to\r\n        // this class template\r\n        this.connectionPoints = [ ]\r\n    }\r\n\r\n    /**\r\n      Returns a connection point that can be used to connect\r\n      a connector to this class template. The new connection\r\n      point is added to this.connectionPoints.\r\n    */\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPoint\"](svg, this)\r\n        this.connectionPoints.push(newPoint)\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        var classTemplateGroup = this.shapeLayer.group().addClass(\"UMLClassTemplate\")\r\n\r\n        let currentDimensions = { \r\n            width: 0,\r\n            height: 0\r\n        }\r\n\r\n        let borderAdjustment = {\r\n            top: this.y + 1,\r\n            left: this.x + 1\r\n        }\r\n    \r\n        var parametersTextGroup = this.textLayer.group().addClass(\"UMLClassTemplateParameters\")\r\n        var parametersText = parametersTextGroup.text(this.classTemplateDescription.parameters[0]).move(borderAdjustment.left + this.style.getLeftMargin(\"classtemplateparameters\"), borderAdjustment.top + this.style.getTopMargin(\"classtemplateparameters\"))\r\n        let parametersRectWidth = (this.style.getLeftMargin(\"classtemplateparameters\") + this.style.getRightMargin(\"classtemplateparameters\") + parametersText.bbox().width)\r\n        let parametersRectHeight = (this.style.getTopMargin(\"classtemplateparameters\") + this.style.getBottomMargin(\"classtemplateparameters\") + parametersText.bbox().height)\r\n\r\n        let y1 = (borderAdjustment.top + this.style.getTopMargin(\"classtemplateparameters\") + (parametersText.bbox().height / 2))\r\n        let y2 = (y1 + this.style.getTopMargin(\"classtemplate\"))\r\n\r\n        let classTemplateNameGroup = this.textLayer.group().addClass(\"UMLClassName\")\r\n        let classTemplateName = classTemplateNameGroup.text(this.classTemplateDescription.name).move(borderAdjustment.left + this.style.getLeftMargin(\"classtemplate\"), y2)\r\n        currentDimensions.width = Math.max(currentDimensions.width, classTemplateName.bbox().width)\r\n        currentDimensions.height = (this.style.getTopMargin(\"classtemplate\") + classTemplateName.bbox().height + this.style.getBottomMargin(\"classtemplate\"))\r\n\r\n        let line1YPos = (borderAdjustment.top + currentDimensions.height + (parametersText.bbox().height / 2))\r\n\r\n        let attributesCompartmentDimensions = _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_2__[\"DrawingUtilities\"].addClassCompartmentText(borderAdjustment.left, line1YPos, this.textLayer, this.style, this.classTemplateDescription.attributes, \"UMLClassAttributes\")\r\n        currentDimensions.width = Math.max(currentDimensions.width, attributesCompartmentDimensions.width)\r\n        currentDimensions.height += attributesCompartmentDimensions.height\r\n\r\n        let line2YPos = (borderAdjustment.top + currentDimensions.height + (parametersText.bbox().height / 2))\r\n\r\n        let operationsCompartmentDimensions = _DrawingUtilities_js__WEBPACK_IMPORTED_MODULE_2__[\"DrawingUtilities\"].addClassCompartmentText(borderAdjustment.left, line2YPos, this.textLayer, this.style, this.classTemplateDescription.operations, \"UMLClassOperations\")\r\n        currentDimensions.width = Math.max(currentDimensions.width, operationsCompartmentDimensions.width)\r\n        currentDimensions.height += operationsCompartmentDimensions.height\r\n\r\n        // According to the UML standard the class name must be\r\n        // centered so center it\r\n        if (currentDimensions.width > classTemplateName.bbox().width) {\r\n            classTemplateName.dx((currentDimensions.width - classTemplateName.bbox().width)/2)\r\n        }\r\n\r\n        currentDimensions.width += (this.style.getLeftMargin(\"classtemplate\") + this.style.getRightMargin(\"classtemplate\"))\r\n        let rect = classTemplateGroup.rect(currentDimensions.width, currentDimensions.height).move(borderAdjustment.left, y1)\r\n        classTemplateGroup.line(borderAdjustment.left, line1YPos, borderAdjustment.left + currentDimensions.width, line1YPos)\r\n        classTemplateGroup.line(borderAdjustment.left, line2YPos, borderAdjustment.left + currentDimensions.width, line2YPos)\r\n\r\n        parametersText.dx(currentDimensions.width - (parametersRectWidth / 2))\r\n\r\n        let parametersRect = classTemplateGroup.rect(parametersRectWidth, parametersRectHeight).move(borderAdjustment.left + currentDimensions.width - (parametersRectWidth / 2), borderAdjustment.top).attr(\"stroke-dasharray\", \"4, 4\")\r\n\r\n        this.connectionPointsRectangle = rect.bbox()\r\n    }\r\n\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle \r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ClassTemplate.js?");

/***/ }),

/***/ "./src/Component.js":
/*!**************************!*\
  !*** ./src/Component.js ***!
  \**************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _BallConnector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BallConnector.js */ \"./src/BallConnector.js\");\n/* harmony import */ var _SocketConnector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SocketConnector.js */ \"./src/SocketConnector.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Stereotype {\r\n\r\n    constructor(svgParentGroup) {\r\n        this.svgParentGroup = svgParentGroup\r\n        this.x = 0\r\n        this.y = 0\r\n        this.width = 15\r\n        this.height = 20\r\n    }\r\n\r\n    move(x, y) {\r\n        this.x = x\r\n        this.y = y\r\n    }\r\n\r\n    draw() {\r\n        let stereoTypeGroup = this.svgParentGroup.group().addClass(\"UMLComponentStereotype\")\r\n        stereoTypeGroup.rect(11, 15).move(4 + this.x, this.y)\r\n        stereoTypeGroup.rect(8, 3).move(this.x, this.y + 3)\r\n        stereoTypeGroup.rect(8, 3).move(this.x, this.y + 9)\r\n    }\r\n\r\n}\r\n\r\n/**\r\n  A component on a component diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Component extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, componentDescription, style) {\r\n        super(svg, \"component\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.svg = svg\r\n        this.componentDescription = componentDescription\r\n        this.style = style\r\n        this.ballConnectors = [ ]\r\n        this.socketConnectors = [ ]\r\n\r\n        if (this.componentDescription.interfaces) {\r\n            for (let i = 0; i < this.componentDescription.interfaces.length; i++) {\r\n                let ballConnector = new _BallConnector_js__WEBPACK_IMPORTED_MODULE_1__[\"BallConnector\"](this.svg, this, this.componentDescription.interfaces[i].name)\r\n                this.ballConnectors.push(ballConnector)\r\n            }\r\n        }\r\n        if (this.componentDescription.dependencies) {\r\n            for (let i = 0; i < this.componentDescription.dependencies.length; i++) {\r\n                let socketConnector = new _SocketConnector_js__WEBPACK_IMPORTED_MODULE_2__[\"SocketConnector\"](this.svg, this, this.componentDescription.dependencies[i].name)\r\n                this.socketConnectors.push(socketConnector)\r\n            }\r\n        }\r\n    }\r\n\r\n    getSocketConnector(name) {\r\n        for (var i = 0; i < this.socketConnectors.length; i++) {\r\n            if (this.socketConnectors[i].name == name) {\r\n                return this.socketConnectors[i]\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    getBallConnector(name) {\r\n        for (var i = 0; i < this.ballConnectors.length; i++) {\r\n            if (this.ballConnectors[i].name == name) {\r\n                return this.ballConnectors[i]\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    createDependencyConnectionPoint(svg, interfaceName) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_3__[\"ConnectionPoint\"](svg, this.getSocketConnector(interfaceName))\r\n        return newPoint\r\n    }\r\n\r\n    createInterfaceConnectionPoint(svg, interfaceName) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_3__[\"ConnectionPoint\"](svg, this.getBallConnector(interfaceName))\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        this.layers.clearEachLayer()\r\n\r\n        var componentGroup = this.shapeLayer.group().addClass(\"UMLComponent\")\r\n\r\n        let offset = 0\r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            offset = Math.max(offset, this.ballConnectors[i].width)\r\n        }\r\n\r\n        let position = {\r\n            x: this.x + 1,\r\n            y: this.y + 1\r\n        }\r\n\r\n        let currentDimensions = {\r\n            width: 0,\r\n            height: 0\r\n        }\r\n\r\n        currentDimensions.height = this.style.getTopMargin(\"component\")\r\n\r\n        let stereotype = new Stereotype(componentGroup)\r\n        currentDimensions.height += stereotype.height\r\n\r\n        var componentNameGroup = this.textLayer.group().addClass(\"UMLComponentName\")\r\n        var componentNameDef = componentNameGroup.text(this.componentDescription.name).addClass(\"UMLComponentName\").move(position.x + offset + this.style.getLeftMargin(\"component\"), position.y + currentDimensions.height)\r\n        currentDimensions.width = Math.max(currentDimensions.width, componentNameDef.bbox().width)\r\n        currentDimensions.height += (componentNameDef.bbox().height + this.style.getBottomMargin(\"component\"))\r\n\r\n        currentDimensions.width += (this.style.getLeftMargin(\"component\") + this.style.getRightMargin(\"component\"))\r\n    \r\n        componentGroup.rect(currentDimensions.width, currentDimensions.height).move(position.x + offset, position.y)\r\n        stereotype.move(position.x + offset + (currentDimensions.width - this.style.getRightMargin(\"component\") - stereotype.width), position.y + this.style.getTopMargin(\"component\"))\r\n        stereotype.draw()\r\n        \r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            this.ballConnectors[i].moveConnectionPoint(position.x, position.y + currentDimensions.height/2)\r\n            this.layers.merge(this.ballConnectors[i].getLayers())\r\n        }\r\n\r\n        for (let i = 0; i < this.socketConnectors.length; i++) {\r\n            this.socketConnectors[i].moveConnectionPoint(position.x + currentDimensions.width + offset, position.y + currentDimensions.height/2)\r\n            this.layers.merge(this.socketConnectors[i].getLayers())\r\n        }\r\n    }\r\n\r\n    getBallConnectionPoint(name) {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            return this.ballConnectors[i].getAssemblyConnectionPoint()\r\n        }\r\n    }\r\n\r\n    getSocketConnectionPoint(name) {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        for (let i = 0; i < this.socketConnectors.length; i++) {\r\n            return this.socketConnectors[i].getAssemblyConnectionPoint()\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Component.js?");

/***/ }),

/***/ "./src/ConnectionPoint.js":
/*!********************************!*\
  !*** ./src/ConnectionPoint.js ***!
  \********************************/
/*! exports provided: ConnectionPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPoint\", function() { return ConnectionPoint; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPointPosition.js */ \"./src/ConnectionPointPosition.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n  <p>\r\n    The point where an element and a connector meet.\r\n  </p>\r\n\r\n  <p>\r\n    Although it derives from {@link DiagramElement} this\r\n    element will probably be invisible to the user. \r\n    However it may be useful to make the connection points\r\n    visible under some circumstances like for instance when\r\n    the diagram is being edited.\r\n  </p>\r\n\r\n  @extends DiagramElement\r\n  @property {DiagramElement} this.element - The element.\r\n  @property {ConnectionPointPosition} this.position - The position\r\n    of the connection point relative to the element.\r\n*/\r\nclass ConnectionPoint extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, element, position = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].BottomCenter) {\r\n        super(svg)\r\n        this.element = element\r\n        this.position = position\r\n    }\r\n\r\n    setPosition(position) {\r\n        this.position = position\r\n\r\n        let x = 0\r\n        let y = 0\r\n        let boundingbox = this.element.getConnectionPointsRectangle()\r\n\r\n        switch (this.position) {\r\n            case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].TopCenter:\r\n                x = boundingbox.cx\r\n                y = boundingbox.y\r\n                break\r\n\r\n            case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].RightCenter:\r\n                x = (boundingbox.x + boundingbox.width)\r\n                y = boundingbox.cy\r\n                break\r\n\r\n            case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].BottomCenter:\r\n                x = boundingbox.cx\r\n                y = (boundingbox.y + boundingbox.height)\r\n                break\r\n\r\n            case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].LeftCenter:\r\n                x = boundingbox.x\r\n                y = boundingbox.cy\r\n                break\r\n        }\r\n\r\n        this.move(x, y)\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ConnectionPoint.js?");

/***/ }),

/***/ "./src/ConnectionPointPosition.js":
/*!****************************************!*\
  !*** ./src/ConnectionPointPosition.js ***!
  \****************************************/
/*! exports provided: ConnectionPointPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPointPosition\", function() { return ConnectionPointPosition; });\n\r\n\r\n/**\r\n  The position of a connection point. These\r\n  are not the coordinates of the connection\r\n  point but a description of where the \r\n  connection point should be relative to the\r\n  element.\r\n*/\r\nclass ConnectionPointPosition {\r\n\r\n    constructor(type) {\r\n        switch (type) {\r\n            case \"top-center\":\r\n                this.type = topCenter\r\n                break\r\n\r\n            case \"top-right\":\r\n                this.type = topRight\r\n                break\r\n\r\n            case \"right-center\":\r\n                this.type = rightCenter\r\n                break\r\n\r\n            case \"bottom-right\":\r\n                this.type = bottomRight\r\n                break\r\n\r\n            case \"bottom-center\":\r\n                this.type = bottomCenter\r\n                break\r\n\r\n            case \"bottom-left\":\r\n                this.type = bottomLeft\r\n                break\r\n\r\n            case \"left-center\":\r\n                this.type = leftCenter\r\n                break\r\n\r\n            case \"top-left\":\r\n                this.type = topLeft\r\n                break\r\n        }\r\n    }\r\n\r\n    equals(other) {\r\n        return (this.type === other.type)\r\n    }\r\n\r\n    static get TopCenter() {\r\n        return staticTopCenter\r\n    }\r\n\r\n    static get TopRight() {\r\n        return staticTopRight\r\n    }\r\n\r\n    static get RightCenter() {\r\n        return staticRightCenter\r\n    }\r\n\r\n    static get BottomRight() {\r\n        return staticBottomRight\r\n    }\r\n\r\n    static get BottomCenter() {\r\n        return staticBottomCenter\r\n    }\r\n\r\n    static get BottomLeft() {\r\n        return staticBottomLeft\r\n    }\r\n\r\n    static get LeftCenter() {\r\n        return staticLeftCenter\r\n    }\r\n\r\n    static get TopLeft() {\r\n        return staticTopLeft\r\n    }\r\n}\r\n\r\nlet topCenter = 0\r\nlet topRight = 1\r\nlet rightCenter = 2\r\nlet bottomRight = 3\r\nlet bottomCenter = 4\r\nlet bottomLeft = 5\r\nlet leftCenter = 6\r\nlet topLeft = 7\r\n\r\nlet staticTopCenter = new ConnectionPointPosition(\"top-center\")\r\nlet staticTopRight = new ConnectionPointPosition(\"top-right\")\r\nlet staticRightCenter = new ConnectionPointPosition(\"right-center\")\r\nlet staticBottomRight = new ConnectionPointPosition(\"bottom-right\")\r\nlet staticBottomCenter = new ConnectionPointPosition(\"bottom-center\")\r\nlet staticBottomLeft = new ConnectionPointPosition(\"bottom-left\")\r\nlet staticLeftCenter = new ConnectionPointPosition(\"left-center\")\r\nlet staticTopLeft = new ConnectionPointPosition(\"top-left\")\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ConnectionPointPosition.js?");

/***/ }),

/***/ "./src/Connector.js":
/*!**************************!*\
  !*** ./src/Connector.js ***!
  \**************************/
/*! exports provided: Connector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Connector\", function() { return Connector; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPointPosition.js */ \"./src/ConnectionPointPosition.js\");\n/* harmony import */ var _Label_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Label.js */ \"./src/Label.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  Represents a connector between elements.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Connector extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, type, connectionPoint1, connectionPoint2, text) {\r\n        super(svg)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.type = type\r\n        this.connectionPoint1 = connectionPoint1\r\n        this.connectionPoint2 = connectionPoint2\r\n        this.label = null\r\n        if (text != null) {\r\n            this.label = new _Label_js__WEBPACK_IMPORTED_MODULE_2__[\"Label\"](text)\r\n        }\r\n        if ((this.label == null) && (type == \"creationmessage\")) {\r\n            this.label = new _Label_js__WEBPACK_IMPORTED_MODULE_2__[\"Label\"](\"new\")\r\n        }\r\n    }\r\n\r\n    hasNonEmptyLabel() {\r\n        return ((this.label != null) && !this.label.empty())\r\n    }\r\n\r\n    doUpdate() {\r\n        this.layers.clearEachLayer()\r\n        if (this.type == \"inheritance\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLInheritanceRelationship\")\r\n            drawInheritanceRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        } else if (this.type == \"composition\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLCompositionRelationship\")\r\n            drawCompositionOrAggregationRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        } else if (this.type == \"aggregation\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLAggregationRelationship\")\r\n            drawCompositionOrAggregationRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        } else if (this.type == \"synchronousmessage\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLSynchronousMessage\")\r\n            let textGroup = null\r\n            if ((this.label != null) && (this.label.text != null) && (this.label.text != \"\")) {\r\n                textGroup = this.textLayer.group()\r\n            }\r\n            drawSynchronousMessage(lineGroup, textGroup, this.connectionPoint1, this.connectionPoint2, this.label)\r\n        } else if (this.type == \"returnmessage\") {\r\n            // If this is return message of a self call draw nothing. It will be indicated on the diagram\r\n            // by a reduction of the depth of the execution specification (i.e. the width of the lifeline)\r\n            if ((this.connectionPoint1.element != null) && (this.connectionPoint1.element != this.connectionPoint2.element)) {\r\n                let lineGroup = this.shapeLayer.group().addClass(\"UMLReturnMessage\")\r\n                drawReturnMessage(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n            }\r\n        } else if (this.type == \"creationmessage\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLCreationMessage\")\r\n            let textGroup = this.textLayer.group()\r\n            drawSynchronousMessage(lineGroup, textGroup, this.connectionPoint1, this.connectionPoint2, this.label)\r\n        } else if (this.type == \"destructionmessage\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLDestructionMessage\")\r\n            drawDestructionMessage(lineGroup, this.connectionPoint2)\r\n        } else if (this.type == \"usecaseassociation\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLUseCaseAssociation\")\r\n            drawUseCaseAssociation(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        } else if (this.type == \"assemblyconnector\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLAssemblyConnector\")\r\n            drawAssemblyConnector(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        } else if (this.type == \"communicationpath\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLCommunicationPath\")\r\n            drawCommunicationPath(lineGroup, this.connectionPoint1, this.connectionPoint2)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Draws an inheritance connector between two classes\r\nfunction drawInheritanceRelationship(lineGroup, connectionPoint1, connectionPoint2) {\r\n    let connectorOrientation = getConnectorHeadOrientationFromPosition(connectionPoint2.position)\r\n    let lineConnectionPoint = getInheritanceArrowLineConnectionPoint(connectionPoint2, connectorOrientation)\r\n    drawConnectorLine(lineGroup, connectionPoint1, lineConnectionPoint, connectorOrientation)\r\n    drawInheritanceArrow(lineGroup, connectionPoint2, connectorOrientation)\r\n}\r\n\r\n// Draws a composition connector between two classes\r\nfunction drawCompositionOrAggregationRelationship(lineGroup, connectionPoint1, connectionPoint2) {\r\n    let connectorOrientation = getConnectorHeadOrientationFromPosition(connectionPoint2.position)\r\n    let lineConnectionPoint = getDiamondLineConnectionPoint(connectionPoint2, connectorOrientation)\r\n    drawConnectorLine(lineGroup, connectionPoint1, lineConnectionPoint, connectorOrientation)\r\n    drawDiamond(lineGroup, connectionPoint2, connectorOrientation)\r\n}\r\n\r\nfunction drawSynchronousMessage(lineGroup, textGroup, connectionPoint1, connectionPoint2, label) {\r\n    if ((connectionPoint1.element != null) && (connectionPoint1.element == connectionPoint2.element)) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = textGroup.text(label.text)\r\n            textElement.move(connectionPoint1.x + 8, connectionPoint1.y - textElement.bbox().height - 3)\r\n        }\r\n\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint1.y)\r\n        lineGroup.line(connectionPoint1.x + 30, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint2.y)\r\n        lineGroup.line(connectionPoint1.x + 30, connectionPoint2.y, connectionPoint2.x + 12, connectionPoint2.y)\r\n        let polygonDescription = \"\" + connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6)\r\n        lineGroup.polygon(polygonDescription)\r\n    } else if (connectionPoint1.x < connectionPoint2.x) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = textGroup.text(label.text)\r\n            \r\n            let width = (connectionPoint2.x - connectionPoint1.x)\r\n            if (textElement.bbox().width < width) {\r\n                textElement.move((connectionPoint1.x + ((width - textElement.bbox().width) / 2)), connectionPoint1.y - textElement.bbox().height - 2)\r\n            } else {\r\n                textElement.move(connectionPoint1.x + 2, connectionPoint1.y - 6 - textElement.bbox().height - 2)\r\n            }\r\n        }\r\n\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x - 12, connectionPoint2.y)\r\n        let polygonDescription = \"\" + (connectionPoint2.x - 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x - 12) + \",\" + (connectionPoint2.y + 6)\r\n        lineGroup.polygon(polygonDescription)\r\n    } else if (connectionPoint1.x > connectionPoint2.x) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = textGroup.text(label.text)\r\n            \r\n            let width = (connectionPoint1.x - connectionPoint2.x)\r\n            if (textElement.bbox().width < width) {\r\n                textElement.move((connectionPoint2.x + ((width - textElement.bbox().width) / 2)), connectionPoint2.y - textElement.bbox().height - 2)\r\n            } else {\r\n                textElement.move(connectionPoint2.x + 2, connectionPoint2.y - 6 - textElement.bbox().height - 2)\r\n            }\r\n        }\r\n\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x + 12, connectionPoint2.y)\r\n        let polygonDescription = \"\" + (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6)\r\n        lineGroup.polygon(polygonDescription)\r\n    } else {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = textGroup.text(label.text)\r\n            textElement.move(connectionPoint1.x + 8, connectionPoint1.y - textElement.bbox().height - 3)\r\n        }\r\n\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint1.y)\r\n        lineGroup.line(connectionPoint1.x + 30, connectionPoint1.y, connectionPoint2.x + 30, connectionPoint2.y)\r\n        lineGroup.line(connectionPoint2.x + 30, connectionPoint2.y, connectionPoint2.x + 12, connectionPoint2.y)\r\n        let polygonDescription = \"\" + connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6)\r\n        lineGroup.polygon(polygonDescription)\r\n    }\r\n}\r\n\r\nfunction drawReturnMessage(lineGroup, connectionPoint1, connectionPoint2) {\r\n    lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint1.y).attr(\"stroke-dasharray\", \"4, 4\")\r\n    if (connectionPoint2.x >= connectionPoint1.x) {\r\n        lineGroup.line(connectionPoint2.x, connectionPoint1.y, connectionPoint2.x - 10, connectionPoint2.y - 6)\r\n        lineGroup.line(connectionPoint2.x, connectionPoint1.y, connectionPoint2.x - 10, connectionPoint2.y + 6)\r\n    } else {\r\n        lineGroup.line(connectionPoint2.x, connectionPoint1.y, connectionPoint2.x + 10, connectionPoint2.y - 6)\r\n        lineGroup.line(connectionPoint2.x, connectionPoint1.y, connectionPoint2.x + 10, connectionPoint2.y + 6)\r\n    }\r\n}\r\n\r\nfunction drawDestructionMessage(lineGroup, connectionPoint2) {\r\n    let halfWidth = 10\r\n    let halfHeight = 10\r\n    lineGroup.line(\r\n        connectionPoint2.x - halfWidth, connectionPoint2.y - halfHeight,\r\n        connectionPoint2.x + halfWidth, connectionPoint2.y + halfHeight\r\n    )\r\n    lineGroup.line(\r\n        connectionPoint2.x - halfWidth, connectionPoint2.y + halfHeight,\r\n        connectionPoint2.x + halfWidth, connectionPoint2.y - halfHeight\r\n    )\r\n}\r\n\r\nfunction drawUseCaseAssociation(lineGroup, connectionPoint1, connectionPoint2) {\r\n    lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y)\r\n}\r\n\r\nfunction drawAssemblyConnector(lineGroup, connectionPoint1, connectionPoint2) {\r\n    if (connectionPoint1.x < connectionPoint2.x) {\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\")\r\n    } else {\r\n        let middlePoint = (connectionPoint1.y + ((connectionPoint2.y - connectionPoint1.y) / 2))\r\n        lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 25, connectionPoint1.y).attr(\"stroke-dasharray\", \"8, 4\")\r\n        lineGroup.line(connectionPoint1.x + 25, connectionPoint1.y, connectionPoint1.x + 25, middlePoint).attr(\"stroke-dasharray\", \"8, 4\")\r\n        lineGroup.line(connectionPoint1.x + 25, middlePoint, connectionPoint2.x - 35, middlePoint).attr(\"stroke-dasharray\", \"8, 4\")\r\n        lineGroup.line(connectionPoint2.x - 35, middlePoint, connectionPoint2.x - 35, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\")\r\n        lineGroup.line(connectionPoint2.x - 35, connectionPoint2.y, connectionPoint2.x, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\")\r\n    }\r\n    lineGroup.line(connectionPoint2.x - 13, connectionPoint2.y + 5, connectionPoint2.x, connectionPoint2.y)\r\n    lineGroup.line(connectionPoint2.x - 13, connectionPoint2.y - 5, connectionPoint2.x, connectionPoint2.y)\r\n}\r\n\r\nfunction drawCommunicationPath(lineGroup, connectionPoint1, connectionPoint2) {\r\n    lineGroup.line(connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y)\r\n}\r\n\r\n// Orientation of the head (e.g. arrow or diamond)\r\n// of a connector\r\nvar ConnectorHeadOrientation = {\r\n    Up: 0,\r\n    Down: 1,\r\n    Left: 2,\r\n    Right: 3\r\n}\r\n\r\n// Get the orientiation of the head of the connector\r\n// based on where the connector is connected\r\nfunction getConnectorHeadOrientationFromPosition(position) {\r\n    switch (position) {\r\n        case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].TopCenter:\r\n            return ConnectorHeadOrientation.Down\r\n        case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].RightCenter:\r\n            return ConnectorHeadOrientation.Left\r\n        case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].BottomCenter:\r\n            return ConnectorHeadOrientation.Up\r\n        case _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].LeftCenter:\r\n            return ConnectorHeadOrientation.Right\r\n    }\r\n}\r\n\r\nfunction getInheritanceArrowLineConnectionPoint(position, orientation) {\r\n    let lineConnectionPoint = { x: 0, y: 0 }\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            lineConnectionPoint = { x: (position.x - 12), y: position.y }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Left:\r\n            lineConnectionPoint = { x: (position.x + 12), y: position.y }\r\n            break\r\n            \r\n        case ConnectorHeadOrientation.Up:\r\n            lineConnectionPoint = { x: position.x, y: (position.y + 12) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Down:\r\n            lineConnectionPoint = { x: position.x, y: (position.y - 12) }\r\n            break\r\n    }\r\n            \r\n    return lineConnectionPoint\r\n}\r\n\r\n// Draws an arrow for an inheritance relationship. The arrow's tip\r\n// is at the position gives as argument.\r\n// It returns the point to which the line of the connector should\r\n// be connected.\r\nfunction drawInheritanceArrow(svg, position, orientation) {\r\n    let secondPoint = { x: 0, y: 0 }\r\n    let thirdPoint = { x: 0, y: 0 }\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            secondPoint = { x: (position.x - 12), y: (position.y - 10) }\r\n            thirdPoint = { x: (position.x - 12), y: (position.y + 10) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Left:\r\n            secondPoint.x = (position.x + 12)\r\n            secondPoint.y = (position.y - 10)\r\n            thirdPoint.x = (position.x + 12)\r\n            thirdPoint.y = (position.y + 10)    \r\n            break\r\n            \r\n        case ConnectorHeadOrientation.Up:\r\n            secondPoint.x = (position.x - 10)\r\n            secondPoint.y = (position.y + 12)\r\n            thirdPoint.x = (position.x + 10)\r\n            thirdPoint.y = (position.y + 12)\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Down:\r\n            secondPoint.x = (position.x - 10)\r\n            secondPoint.y = (position.y - 12)\r\n            thirdPoint.x = (position.x + 10)\r\n            thirdPoint.y = (position.y - 12)\r\n            break\r\n    }\r\n            \r\n    let polygonDescription = \"\" + position.x + \",\" + position.y + \" \" +\r\n        secondPoint.x + \",\" + secondPoint.y + \" \" +\r\n        thirdPoint.x + \",\" + thirdPoint.y                \r\n    svg.polygon(polygonDescription)\r\n}\r\n\r\nfunction getDiamondLineConnectionPoint(position, orientation) {\r\n    let thirdPoint = { x: 0, y: 0 }\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            thirdPoint = { x: (position.x - 20), y: position.y }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Left:\r\n            thirdPoint = { x: (position.x + 20), y: position.y }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Up:\r\n            thirdPoint = { x: position.x, y: (position.y + 20) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Down:\r\n            thirdPoint = { x: position.x, y: (position.y - 20) }\r\n            break\r\n    }\r\n\r\n    return thirdPoint\r\n}\r\n\r\n// Draws a diamond for an inheritance relationship. The arrow's tip\r\n// is at the position gives as argument.\r\n// It returns the point to which the line of the connector should\r\n// be connected.\r\nfunction drawDiamond(svg, position, orientation) {\r\n    let secondPoint = { x: 0, y: 0 }\r\n    let thirdPoint = { x: 0, y: 0 }\r\n    let fourthPoint = { x: 0, y: 0 }\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            secondPoint = { x: (position.x - 10), y: (position.y - 8) }\r\n            thirdPoint = { x: (position.x - 20), y: position.y }\r\n            fourthPoint = { x: (position.x - 10), y: (position.y + 8) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Left:\r\n            secondPoint = { x: (position.x + 10), y: (position.y - 8) }\r\n            thirdPoint = { x: (position.x + 20), y: position.y }\r\n            fourthPoint = { x: (position.x + 10), y: (position.y + 8) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Up:\r\n            secondPoint = { x: (position.x + 8), y: (position.y + 10) }\r\n            thirdPoint = { x: position.x, y: (position.y + 20) }\r\n            fourthPoint = { x: (position.x - 8), y: (position.y + 10) }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Down:\r\n            secondPoint = { x: (position.x + 8), y: (position.y - 10) }\r\n            thirdPoint = { x: position.x, y: (position.y - 20) }\r\n            fourthPoint = { x: (position.x - 8), y: (position.y - 10) }\r\n            break\r\n    }\r\n\r\n    let polygonDescription = \"\" + position.x + \",\" + position.y + \" \" +\r\n        secondPoint.x + \",\" + secondPoint.y + \" \" +\r\n        thirdPoint.x + \",\" + thirdPoint.y + \" \" +\r\n        fourthPoint.x + \",\" + fourthPoint.y\r\n    svg.polygon(polygonDescription)\r\n}\r\n\r\nfunction drawConnectorLine(svg, startPoint, endPoint, orientation) {\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Up:\r\n        case ConnectorHeadOrientation.Down:\r\n            let shape1 = getConnectorLineShape1(startPoint, endPoint, orientation)\r\n            switch (shape1) {\r\n                case ConnectorLineShape.Straight:\r\n                    svg.line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)\r\n                    break\r\n\r\n                case ConnectorLineShape.TopRightCorner:\r\n                case ConnectorLineShape.TopLeftCorner:\r\n                case ConnectorLineShape.BottomRightCorner:\r\n                case ConnectorLineShape.BottomLeftCorner:\r\n                    svg.line(startPoint.x, startPoint.y, endPoint.x, startPoint.y)\r\n                    svg.line(endPoint.x, startPoint.y, endPoint.x, endPoint.y)\r\n                    break\r\n\r\n                case ConnectorLineShape.HorizontalStep:\r\n                    let middleY = (endPoint.y + ((startPoint.y - endPoint.y)/2))\r\n                    svg.line(startPoint.x, startPoint.y, startPoint.x, middleY)\r\n                    svg.line(startPoint.x, middleY, endPoint.x, middleY)\r\n                    svg.line(endPoint.x, middleY, endPoint.x, endPoint.y)\r\n                    break\r\n            }\r\n            break\r\n\r\n        case ConnectorHeadOrientation.Left:\r\n        case ConnectorHeadOrientation.Right:\r\n            let shape2 = getConnectorLineShape2(startPoint, endPoint, orientation)\r\n            switch (shape2) {\r\n                case ConnectorLineShape.Straight:\r\n                    svg.line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)\r\n                    break\r\n\r\n                case ConnectorLineShape.TopRightCorner:\r\n                case ConnectorLineShape.TopLeftCorner:\r\n                case ConnectorLineShape.BottomRightCorner:\r\n                case ConnectorLineShape.BottomLeftCorner:\r\n                    svg.line(startPoint.x, startPoint.y, startPoint.x, endPoint.y)\r\n                    svg.line(startPoint.x, endPoint.y, endPoint.x, endPoint.y)\r\n                    break\r\n\r\n                case ConnectorLineShape.VerticalStep:\r\n                    let middleX = (endPoint.x + ((startPoint.x - endPoint.x)/2))\r\n                    svg.line(startPoint.x, startPoint.y, middleX, startPoint.y)\r\n                    svg.line(middleX, startPoint.y, middleX, endPoint.y)\r\n                    svg.line(middleX, endPoint.y, endPoint.x, endPoint.y)\r\n                    break\r\n            }\r\n            break\r\n    }\r\n}\r\n\r\n// Orientation of the head (e.g. arrow or diamond)\r\n// of a connector\r\nvar ConnectorLineShape = {\r\n    Straight: 0,\r\n    TopRightCorner: 1,\r\n    TopLeftCorner: 2,\r\n    BottomRightCorner: 3,\r\n    BottomLeftCorner: 4,\r\n    HorizontalStep: 5,\r\n    VerticalStep: 6\r\n}\r\n\r\nfunction getConnectorLineShape1(startPoint, endPoint, orientation) {\r\n    let result = ConnectorLineShape.Straight\r\n    if (endPoint.x == startPoint.x) {\r\n        result = ConnectorLineShape.Straight\r\n    } else if ((orientation == ConnectorHeadOrientation.Down) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].RightCenter)) {\r\n        result = ConnectorLineShape.TopRightCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Down) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].LeftCenter)) {\r\n        result = ConnectorLineShape.TopLeftCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Up) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].RightCenter)) {\r\n        result = ConnectorLineShape.BottomRightCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Up) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].LeftCenter)) {\r\n        result = ConnectorLineShape.BottomLeftCorner\r\n    } else {\r\n        result = ConnectorLineShape.HorizontalStep\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getConnectorLineShape2(startPoint, endPoint, orientation) {\r\n    let result = ConnectorLineShape.Straight\r\n    if (endPoint.y == startPoint.y) {\r\n        result = ConnectorLineShape.Straight\r\n    } else if ((orientation == ConnectorHeadOrientation.Right) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].BottomCenter)) {\r\n        result = ConnectorLineShape.BottomLeftCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Right) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].TopCenter)) {\r\n        result = ConnectorLineShape.TopLeftCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Left) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].BottomCenter)) {\r\n        result = ConnectorLineShape.BottomRightCorner\r\n    } else if ((orientation == ConnectorHeadOrientation.Left) && (startPoint.position == _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPointPosition\"].TopCenter)) {\r\n        result = ConnectorLineShape.TopRightCorner\r\n    } else {\r\n        result = ConnectorLineShape.VerticalStep\r\n    }\r\n    return result\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Connector.js?");

/***/ }),

/***/ "./src/Diagram.js":
/*!************************!*\
  !*** ./src/Diagram.js ***!
  \************************/
/*! exports provided: Diagram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Diagram\", function() { return Diagram; });\n/* harmony import */ var _UMLWebWidgetError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UMLWebWidgetError.js */ \"./src/UMLWebWidgetError.js\");\n/* harmony import */ var _Settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Settings.js */ \"./src/Settings.js\");\n/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Style.js */ \"./src/Style.js\");\n/* harmony import */ var _LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LayoutManager.js */ \"./src/LayoutManager.js\");\n/* harmony import */ var _ClassBox_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ClassBox.js */ \"./src/ClassBox.js\");\n/* harmony import */ var _ClassTemplate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ClassTemplate.js */ \"./src/ClassTemplate.js\");\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony import */ var _Lifeline_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Lifeline.js */ \"./src/Lifeline.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Node.js */ \"./src/Node.js\");\n/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Actor.js */ \"./src/Actor.js\");\n/* harmony import */ var _UseCase_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./UseCase.js */ \"./src/UseCase.js\");\n/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Connector.js */ \"./src/Connector.js\");\n/* harmony import */ var _SVGLayer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SVGLayer.js */ \"./src/SVGLayer.js\");\n/* harmony import */ var _Log_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Log.js */ \"./src/Log.js\");\n/* harmony import */ var _Metrics_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Metrics.js */ \"./src/Metrics.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  This class is the entry point for all the functionality provided\r\n  by the CodeSmithy UMLWebWidget.\r\n*/\r\nclass Diagram {\r\n\r\n    constructor(settings) {\r\n        this.settings = new _Settings_js__WEBPACK_IMPORTED_MODULE_1__[\"Settings\"](settings)\r\n        this.log = new _Log_js__WEBPACK_IMPORTED_MODULE_13__[\"Log\"](this.settings.logLevel)\r\n        this.metrics = new _Metrics_js__WEBPACK_IMPORTED_MODULE_14__[\"Metrics\"]()\r\n        \r\n        // The description of the UML diagram in JSON\r\n        // format. This will then be parsed to create\r\n        // the graphical form.\r\n        this.diagramDescription = { }\r\n\r\n        // The list of all UML class boxes present on the\r\n        // diagram\r\n        this.classboxes = new Map()\r\n\r\n        // The list of all UML class templates present on the\r\n        // diagram\r\n        this.classtemplates = new Map()\r\n\r\n        // The list of all UML lifelines present on the\r\n        // diagram\r\n        this.lifelines = new Map()\r\n\r\n        // The list of all UML components present on the\r\n        // diagram\r\n        this.components = new Map()\r\n\r\n        this.nodes = new Map()\r\n\r\n        // The list of all UML actors present on the\r\n        // diagram\r\n        this.actors = new Map()\r\n\r\n        // The list of all UML use cases present on the\r\n        // diagram\r\n        this.usecases = new Map()\r\n\r\n        this.messages = [ ]\r\n    }\r\n\r\n    // Create a diagram from a div element in the HTML document.\r\n    // The div element must contain a JSON object with the UML\r\n    // diagram information. The contents of the div will be replaced\r\n    // by the diagram.\r\n    // - divId: this is the id of the div element to use, it should be the id\r\n    //   without any '#' prefix.\r\n    createFromDiv(divId, layout) {\r\n        let jsonDiagramDescription = JSON.parse($('#' + divId).text())\r\n        $('#' + divId).empty()\r\n        var svg = SVG(divId).size(this.settings.width, this.settings.height)\r\n        this.createFromJSON(svg, jsonDiagramDescription, layout)\r\n    }\r\n\r\n    createFromJSON(svg, jsonDiagramDescription, layout) {\r\n        if (jsonDiagramDescription == null) {\r\n            jsonDiagramDescription = { }\r\n        }\r\n        this.diagramDescription = jsonDiagramDescription\r\n        let style = new _Style_js__WEBPACK_IMPORTED_MODULE_2__[\"Style\"]()\r\n\r\n        if (this.diagramDescription.elements) {\r\n            this.drawDiagram(svg, this.diagramDescription.elements, style, layout)\r\n        }\r\n    }\r\n\r\n    drawDiagram(svg, description, style, layout) {\r\n        let layoutManager = new _LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__[\"LayoutManager\"](layout)\r\n\r\n        let connectors = []\r\n        let assemblyconnectors = []\r\n\r\n        // Construct the elements\r\n        for (var i = 0; i < description.length; i++) {\r\n            let item = description[i]\r\n            if (item.class) {\r\n                this.classboxes.set(\r\n                    item.class.name,\r\n                    new _ClassBox_js__WEBPACK_IMPORTED_MODULE_4__[\"ClassBox\"](svg, item.class.name, item.class, this.settings.canMove, style)\r\n                )\r\n            } else if (item.classtemplate) {\r\n                this.classtemplates.set(\r\n                    item.classtemplate.name,\r\n                    new _ClassTemplate_js__WEBPACK_IMPORTED_MODULE_5__[\"ClassTemplate\"](svg, item.classtemplate.name, item.classtemplate, style)\r\n                )\r\n            } else if (item.lifeline) {\r\n                this.lifelines.set(\r\n                    item.lifeline.name,\r\n                    new _Lifeline_js__WEBPACK_IMPORTED_MODULE_7__[\"Lifeline\"](svg, item.lifeline.name, item.lifeline, style, this.log)\r\n                )\r\n            } else if (item.component) {\r\n                this.components.set(\r\n                     item.component.name,\r\n                     new _Component_js__WEBPACK_IMPORTED_MODULE_6__[\"Component\"](svg, item.component.name, item.component, style)\r\n                )\r\n            } else if (item.node) {\r\n                this.nodes.set(\r\n                    item.node.name,\r\n                    new _Node_js__WEBPACK_IMPORTED_MODULE_8__[\"Node\"](svg, item.node.name, item.node, style)\r\n                )\r\n            } else if (item.actor) {\r\n                this.actors.set(\r\n                    item.actor.name,\r\n                    new _Actor_js__WEBPACK_IMPORTED_MODULE_9__[\"Actor\"](svg, item.actor.name, item.actor)\r\n                )\r\n            } else if (item.usecase) {\r\n                this.usecases.set(\r\n                    item.usecase.title,\r\n                    new _UseCase_js__WEBPACK_IMPORTED_MODULE_10__[\"UseCase\"](svg, item.usecase.title, item.usecase)\r\n                )\r\n            } else if (item.relationship) {\r\n                let classbox1\r\n                let classbox2\r\n                if (item.relationship.type == \"inheritance\") {\r\n                    classbox1 = this.classboxes.get(item.relationship.derivedclass)\r\n                    if (classbox1 == null) {\r\n                        classbox1 = this.classtemplates.get(item.relationship.derivedclass)\r\n                    }\r\n                    classbox2 = this.classboxes.get(item.relationship.baseclass)\r\n                    if (classbox2 == null) {\r\n                        classbox2 = this.classtemplates.get(item.relationship.baseclass)\r\n                    }\r\n                } else if ((item.relationship.type == \"composition\") || (item.relationship.type == \"aggregation\")) {\r\n                    classbox1 = this.classboxes.get(item.relationship.containedclass)\r\n                    classbox2 = this.classboxes.get(item.relationship.containingclass)\r\n                }\r\n                let connectionPoint1 = classbox1.createConnectionPoint(svg)\r\n                let connectionPoint2 = classbox2.createConnectionPoint(svg)\r\n                let newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, item.relationship.type, connectionPoint1, connectionPoint2)\r\n                connectors.push(newConnector)\r\n            } else if (item.messages) {\r\n                for (var j = 0; j < item.messages.length; j++) {\r\n                    let message = item.messages[j]\r\n                    let newConnector\r\n                    if (message.synchronousmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.synchronousmessage.caller)\r\n                        let lifeline2 = this.lifelines.get(message.synchronousmessage.callee)\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"synchronous-start\")\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"synchronous-end\")\r\n                        newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"synchronousmessage\", connectionPoint1, connectionPoint2, message.synchronousmessage.name)\r\n                    } else if (message.returnmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.returnmessage.callee)\r\n                        let lifeline2 = this.lifelines.get(message.returnmessage.caller)\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"return-start\")\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"return-end\")\r\n                        newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"returnmessage\", connectionPoint1, connectionPoint2, null)\r\n                    } else if (message.creationmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.creationmessage.caller)\r\n                        let lifeline2 = this.lifelines.get(message.creationmessage.callee)\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"creation-start\")\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"creation-end\")\r\n                        newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"creationmessage\", connectionPoint1, connectionPoint2, null)\r\n                    } else if (message.destructionmessage) {\r\n                        let lifeline2 = this.lifelines.get(message.destructionmessage.callee)\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"destruction-end\")\r\n                        newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"destructionmessage\", connectionPoint2, connectionPoint2, \"\")\r\n                    }\r\n                    this.messages.push(newConnector)\r\n                }\r\n            } else if (item.assemblyconnector) {\r\n                let consumerComponent = this.components.get(item.assemblyconnector.consumer)\r\n                let providerComponent = this.components.get(item.assemblyconnector.provider)\r\n                let connectionPoint1 = consumerComponent.createDependencyConnectionPoint(svg, item.assemblyconnector.interface)\r\n                let connectionPoint2 = providerComponent.createInterfaceConnectionPoint(svg, item.assemblyconnector.interface)\r\n                let newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"assemblyconnector\", connectionPoint1, connectionPoint2)\r\n                assemblyconnectors.push(newConnector)\r\n            } else if (item.association) {\r\n                let connectionPoint1 = this.actors.get(item.association.actor).createConnectionPoint(svg)\r\n                let connectionPoint2 = this.usecases.get(item.association.usecase).createConnectionPoint(svg)\r\n                let newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"usecaseassociation\", connectionPoint1, connectionPoint2)\r\n                connectors.push(newConnector)\r\n            } else if (item.communicationpath) {\r\n                let connectionPoint1 = this.nodes.get(item.communicationpath.firstnode).createConnectionPoint(svg)\r\n                let connectionPoint2 = this.nodes.get(item.communicationpath.secondnode).createConnectionPoint(svg)\r\n                let newConnector = new _Connector_js__WEBPACK_IMPORTED_MODULE_11__[\"Connector\"](svg, \"communicationpath\", connectionPoint1, connectionPoint2)\r\n                connectors.push(newConnector)\r\n            }\r\n        }\r\n\r\n        layoutManager.doLayout(this)\r\n        dolayout(layoutManager, connectors, assemblyconnectors)\r\n\r\n        draw(this.classboxes.values(), this.classtemplates.values(), this.lifelines.values(), this.components.values(), this.nodes.values(), \r\n            this.actors.values(), this.usecases.values(), connectors, this.messages, assemblyconnectors)\r\n    }\r\n\r\n}\r\n\r\nfunction dolayout(layoutManager, connectors, assemblyconnectors) {\r\n    if (connectors != null) {\r\n        layoutManager.layoutConnectors(connectors)\r\n    }\r\n    if (assemblyconnectors != null) {\r\n        for (var i = 0; i < assemblyconnectors.length; i++) {\r\n            let connector = assemblyconnectors[i]\r\n            connector.connectionPoint1.move(connector.connectionPoint1.element.component.getSocketConnectionPoint(\"\").x, connector.connectionPoint1.element.component.getSocketConnectionPoint(\"\").y)\r\n            connector.connectionPoint2.move(connector.connectionPoint2.element.component.getBallConnectionPoint(\"\").x, connector.connectionPoint2.element.component.getBallConnectionPoint(\"\").y)\r\n        }\r\n    }\r\n}\r\n\r\nfunction draw(classboxes, classtemplates, lifelines, components, nodes, actors, usecases, connectors, messages, assemblyconnectors) {\r\n    if (classboxes != null) {\r\n        for (let classbox of classboxes) {\r\n            classbox.getLayers().getLayer(\"shape\").write()\r\n            classbox.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (classtemplates != null) {\r\n        for (let classtemplate of classtemplates) {\r\n            classtemplate.getLayers().getLayer(\"shape\").write()\r\n            classtemplate.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (lifelines != null) {\r\n        for (let lifeline of lifelines) {\r\n            lifeline.getLayers().getLayer(\"shape\").write()\r\n            lifeline.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (components != null) {\r\n        for (let component of components) {\r\n            component.getLayers().getLayer(\"shape\").write()\r\n            component.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (nodes != null) {\r\n        for (let node of nodes) {\r\n            node.getLayers().getLayer(\"shape\").write()\r\n            node.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (actors != null) {\r\n        for (let actor of actors) {\r\n            actor.getLayers().getLayer(\"shape\").write()\r\n            actor.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    if (usecases != null) {\r\n        for (let usecase of usecases) {\r\n            usecase.getLayers().getLayer(\"shape\").write()\r\n            usecase.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n    for (var i = 0; i < connectors.length; i++) {\r\n        let connector = connectors[i]\r\n        connector.getLayers().getLayer(\"shape\").write()\r\n        connector.getLayers().getLayer(\"text\").write()\r\n    }\r\n    for (var i = 0; i < messages.length; i++) {\r\n        let connector = messages[i]\r\n        connector.getLayers().getLayer(\"shape\").write()\r\n        connector.getLayers().getLayer(\"text\").write()\r\n    }\r\n    if (assemblyconnectors != null) {\r\n        for (var i = 0; i < assemblyconnectors.length; i++) {\r\n            let connector = assemblyconnectors[i]\r\n            connector.getLayers().getLayer(\"shape\").write()\r\n            connector.getLayers().getLayer(\"text\").write()\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Diagram.js?");

/***/ }),

/***/ "./src/DiagramElement.js":
/*!*******************************!*\
  !*** ./src/DiagramElement.js ***!
  \*******************************/
/*! exports provided: DiagramElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiagramElement\", function() { return DiagramElement; });\n/* harmony import */ var _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGLayerSet.js */ \"./src/SVGLayerSet.js\");\n\r\n\r\n\r\n\r\nvar position = Symbol()\r\n\r\n/**\r\n  An element of a diagram.\r\n\r\n  @property {SVGLayerSet} this.layers - The various SVG layers\r\n    to use to render this element.\r\n  @property {boolean} this.uptodate - Whether the layers need \r\n    to be updated because of changes to the element.\r\n*/\r\nclass DiagramElement {\r\n\r\n    /**\r\n      Creates a new DiagramElement instance.\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n      @param {string} id - A unique identifier for this element.\r\n    */\r\n    constructor(svg, type, id) {\r\n        this.type = type\r\n        this.id = id\r\n        this.layers = new _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__[\"SVGLayerSet\"](svg)\r\n        this.uptodate = false\r\n        this[position] = { x: 0, y: 0 }\r\n    }\r\n\r\n    /**\r\n      Gets the layers of the element. This checks\r\n      if any changes were made to the element and calls\r\n      {@link DiagramElement#update} if necessary before\r\n      returning the layers.\r\n      @returns {SVGLayerSet} The SVG layers to use to draw the\r\n        element.\r\n    */\r\n    getLayers() {\r\n        this.update()\r\n        return this.layers\r\n    }\r\n\r\n    get x() {\r\n        return this[position].x\r\n    }\r\n\r\n    get y() {\r\n        return this[position].y\r\n    }\r\n\r\n    move(x, y) {\r\n        this.uptodate = false\r\n        this[position].x = x\r\n        this[position].y = y\r\n    }\r\n\r\n    /**\r\n      Returns the rectangle on which connection points\r\n      can be placed. Returns null if no connection points\r\n      are allowed or where they can be placed can't be\r\n      expressed as a rectangle.\r\n    */\r\n    getConnectionPointsRectangle() {\r\n        this.update()\r\n        return this.doGetConnectionPointsRectangle()\r\n    }\r\n\r\n    update() {\r\n        if (!this.uptodate) {\r\n            this.doUpdate()\r\n            this.uptodate = true\r\n        }\r\n    }\r\n\r\n    /**\r\n      This function must be called after changes were\r\n      made to update the contents of the SVG layers.\r\n\r\n      @virtual\r\n    */\r\n    doUpdate() {\r\n    }\r\n\r\n    /**\r\n       Implements the getConnectionPointsRectangle method.\r\n\r\n      @virtual\r\n    */\r\n    doGetConnectionPointsRectangle() {\r\n        return null\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/DiagramElement.js?");

/***/ }),

/***/ "./src/DrawingUtilities.js":
/*!*********************************!*\
  !*** ./src/DrawingUtilities.js ***!
  \*********************************/
/*! exports provided: DrawingUtilities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrawingUtilities\", function() { return DrawingUtilities; });\n\r\n\r\nclass DrawingUtilities {\r\n\r\n    // Add an attribute or operation compartment and updates the current dimensions\r\n    // of the class box\r\n    static addClassCompartmentText(x, y, textLayer, style, items, cssClass) {\r\n        y += style.getTopMargin(\"classbox\")\r\n        let dimensions = createAttributeOrOperationGroupDef(x + style.getLeftMargin(\"classbox\"), y, textLayer, items, cssClass)\r\n        dimensions.height += (style.getTopMargin(\"classbox\") + style.getBottomMargin(\"classbox\"))\r\n        return dimensions\r\n    }\r\n\r\n}\r\n\r\n// Creates a group with all the attributes or operations\r\nfunction createAttributeOrOperationGroupDef(x, y, textLayer, items, cssClass) {\r\n    let width = 0\r\n    let height = 0\r\n    let itemGroupDef = textLayer.group().addClass(cssClass)\r\n    for (var i = 0; i < items.length; i++) {\r\n        let itemDef = createAttributeOrOperationDef(itemGroupDef, items[i])\r\n        itemDef.move(x, y + height)\r\n        width = Math.max(width, itemDef.bbox().width)\r\n        height += itemDef.bbox().height\r\n    }\r\n    return { width: width, height: height }\r\n}\r\n\r\n// Creates a single attribute or operation line\r\nfunction createAttributeOrOperationDef(svg, item) {\r\n    let text = visibilityStringToSymbol(item.visibility) + item.name\r\n    if (item.return) {\r\n        text += \" : \" + item.return\r\n    }\r\n    return svg.text(text)\r\n}\r\n\r\n// Converts the visibility from the user string provided\r\n// in the input to the appropriate UML symbol for\r\n// visibility\r\nfunction visibilityStringToSymbol(visibility) {\r\n    let stringToSymbolMap = {\r\n        \"public\": \"+ \",\r\n        \"protected\": \"# \",\r\n        \"private\": \"- \"\r\n    }\r\n    return stringToSymbolMap[visibility]\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/DrawingUtilities.js?");

/***/ }),

/***/ "./src/Label.js":
/*!**********************!*\
  !*** ./src/Label.js ***!
  \**********************/
/*! exports provided: Label */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Label\", function() { return Label; });\n\r\n\r\nclass Label {\r\n\r\n    constructor(text) {\r\n        this.text = text\r\n    }\r\n\r\n    empty() {\r\n        return ((this.text == null) || (this.text == \"\"))\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Label.js?");

/***/ }),

/***/ "./src/LayoutManager.js":
/*!******************************!*\
  !*** ./src/LayoutManager.js ***!
  \******************************/
/*! exports provided: LayoutManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LayoutManager\", function() { return LayoutManager; });\n/* harmony import */ var _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConnectionPointPosition.js */ \"./src/ConnectionPointPosition.js\");\n\r\n\r\n\r\n\r\n/** Sets the position of the elements on the diagram. */\r\nclass LayoutManager {\r\n\r\n    constructor(layout) {\r\n        this.layout = layout\r\n        if (this.layout == null) {\r\n            this.layout = { }\r\n        }\r\n        if (this.layout.elements == null) {\r\n            this.layout.elements = { }\r\n        }\r\n        if (this.layout.connectorpositions == null) {\r\n            this.layout.connectorpositions = { }\r\n        }\r\n    }\r\n\r\n    doLayout(diagram) {\r\n        for (let classbox of diagram.classboxes.values()) {\r\n            this.setElementPosition(classbox)\r\n        }\r\n        for (let lifeline of diagram.lifelines.values()) {\r\n            this.setElementPosition(lifeline)\r\n        }\r\n        for (let component of diagram.components.values()) {\r\n            this.setElementPosition(component)\r\n        }\r\n        for (let node of diagram.nodes.values()) {\r\n            this.setElementPosition(node)\r\n        }\r\n        for (let actor of diagram.actors.values()) {\r\n            this.setElementPosition(actor)\r\n        }\r\n        for (let usecase of diagram.usecases.values()) {\r\n            this.setElementPosition(usecase)\r\n        }\r\n        this.layoutMessages(diagram.lifelines, diagram.messages)\r\n    }\r\n\r\n    setElementPosition(element) {\r\n        let elementLayout = this.layout.elements[element.id]\r\n        if (elementLayout) {\r\n            if (elementLayout.position) {\r\n                element.move(elementLayout.position.x, elementLayout.position.y)\r\n            }\r\n        }\r\n    }\r\n\r\n    layoutConnectors(connectors) {\r\n        for (var i = 0; i < connectors.length; i++) {\r\n            let connector = connectors[i]\r\n            let connectionPoint1 = connector.connectionPoint1\r\n            let connectionPoint2 = connector.connectionPoint2\r\n            let bbox1 = connectionPoint1.element.getConnectionPointsRectangle()\r\n            let bbox2 = connectionPoint2.element.getConnectionPointsRectangle()\r\n            let connectionPositions = this.getConnectionPositions(bbox1, bbox2, connector.type)\r\n\r\n            let connectorId = connectionPoint1.element.id + \"-\" + connectionPoint2.element.id + \"-\" + connector.type\r\n            let layoutOverride = this.layout.elements[connectorId]\r\n            if (layoutOverride) {\r\n                if (layoutOverride.end) {\r\n                    switch (layoutOverride.end) {\r\n                        case \"top-center\":\r\n                            connectionPositions.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n                            break\r\n\r\n                        case \"right-center\":\r\n                            connectionPositions.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].RightCenter\r\n                            break\r\n\r\n                       case \"bottom-center\":\r\n                            connectionPositions.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].BottomCenter\r\n                            break\r\n\r\n                        case \"left-center\":\r\n                            connectionPositions.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].LeftCenter\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            connectionPoint1.setPosition(connectionPositions.start)\r\n            connectionPoint2.setPosition(connectionPositions.end)\r\n        }\r\n    }\r\n\r\n    layoutMessages(lifelines, connectors) {\r\n        let currrentYPosition = 0\r\n        for (let lifeline of lifelines.values()) {\r\n            currrentYPosition = Math.max(currrentYPosition, lifeline.getFirstConnectionPointPosition().y)\r\n        }\r\n        let firstConnector = true\r\n        for (let connector of connectors) {\r\n            if (firstConnector) {\r\n                firstConnector = false\r\n                if (connector.hasNonEmptyLabel() && (connector.type != \"creationmessage\")) {\r\n                    currrentYPosition += 10\r\n                }\r\n            } else {\r\n                if (connector.hasNonEmptyLabel()) {\r\n                    currrentYPosition += 16\r\n                }\r\n            }\r\n            let connectionPoint1 = connector.connectionPoint1\r\n            let connectionPoint2 = connector.connectionPoint2\r\n            let lifeline1 = connectionPoint1.element\r\n            let lifeline2 = connectionPoint2.element\r\n            if ((connector.type != \"creationmessage\") && (connector.type != \"destructionmessage\")) {\r\n                if (lifeline1 != lifeline2) {\r\n                    connectionPoint1.move(lifeline1.getLineTopPosition().x, currrentYPosition)\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition)\r\n                    currrentYPosition += 14\r\n                } else {\r\n                    connectionPoint1.move(lifeline1.getLineTopPosition().x, currrentYPosition)\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition + 20)\r\n                    if (connector.type != \"returnmessage\") {\r\n                        currrentYPosition += 34\r\n                    }\r\n                }\r\n            } else if (connector.type == \"creationmessage\") {\r\n                lifeline2.move(lifeline2.x, currrentYPosition)\r\n                let y = lifeline2.getCreationConnectionPointPosition().y\r\n                connectionPoint1.move(lifeline1.getLineTopPosition().x, y)\r\n                connectionPoint2.move(lifeline2.getCreationConnectionPointPosition().x, y)\r\n                currrentYPosition += 34\r\n            } else if (connector.type == \"destructionmessage\") {\r\n                if (lifeline2.needToAdjustDestructionPosition()) {\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition + 25)\r\n                } else {\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition)\r\n                }\r\n                currrentYPosition += 14\r\n            }\r\n        }\r\n        if (connectors.length > 0) {\r\n            for (let lifeline of lifelines.values()) {\r\n                lifeline.doLayout()\r\n                lifeline.uptodate = false\r\n            }\r\n        }\r\n\r\n        // Do a second pass to adjust the x position based on the width of the \r\n        // line which varies because of execution specifications\r\n        for (let connector of connectors) {\r\n            let connectionPoint1 = connector.connectionPoint1\r\n            let connectionPoint2 = connector.connectionPoint2\r\n            let lifeline1 = connectionPoint1.element\r\n            let lifeline2 = connectionPoint2.element\r\n            if (lifeline1 == lifeline2) {\r\n                let y1 = connectionPoint1.y\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"right\")\r\n                connectionPoint1.move(x1, y1)\r\n                let y2 = connectionPoint2.y\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"right\")\r\n                connectionPoint2.move(x2, y2)\r\n            } else if (lifeline2.x >= lifeline1.x) {\r\n                let y1 = connectionPoint1.y\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"right\")\r\n                connectionPoint1.move(x1, y1)\r\n                let y2 = connectionPoint2.y\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"left\")\r\n                connectionPoint2.move(x2, y2)\r\n            } else {\r\n                let y1 = connectionPoint1.y\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"left\")\r\n                connectionPoint1.move(x1, y1)\r\n                let y2 = connectionPoint2.y\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"right\")\r\n                connectionPoint2.move(x2, y2)\r\n\r\n            }\r\n            connector.uptodate = false\r\n        }\r\n    }\r\n\r\n    getConnectionPositions(boundingbox1, boundingbox2, type) {\r\n        let result = { \r\n            start: _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter,\r\n            end: _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n        }\r\n\r\n        if (type != \"usecaseassociation\") {\r\n            if ((boundingbox2.y + boundingbox2.height) < boundingbox1.y) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].BottomCenter\r\n            } else if ((boundingbox1.y + boundingbox1.height) < boundingbox2.y) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].BottomCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n            } else if ((boundingbox2.x + boundingbox2.width) < boundingbox1.x) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].LeftCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].RightCenter\r\n            } else if ((boundingbox1.x + boundingbox1.width) < boundingbox2.x) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].RightCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].LeftCenter\r\n            }\r\n        } else {\r\n            if (boundingbox1.x < boundingbox2.x) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].RightCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].LeftCenter\r\n            } else if (boundingbox1.x > (boundingbox2.x + boundingbox2.width)) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].LeftCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].RightCenter\r\n            } else if (boundingbox1.y < boundingbox2.y) {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].BottomCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n            } else {\r\n                result.start = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].TopCenter\r\n                result.end = _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_0__[\"ConnectionPointPosition\"].BottomCenter\r\n            }\r\n        }\r\n\r\n        return result\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/LayoutManager.js?");

/***/ }),

/***/ "./src/Lifeline.js":
/*!*************************!*\
  !*** ./src/Lifeline.js ***!
  \*************************/
/*! exports provided: Lifeline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lifeline\", function() { return Lifeline; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n/* harmony import */ var _SVGLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SVGLayer.js */ \"./src/SVGLayer.js\");\n/* harmony import */ var _LifelineLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LifelineLayout.js */ \"./src/LifelineLayout.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  A lifeline on a sequence diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Lifeline extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    /**\r\n      <p>Creates a new Lifeline instance.</p>\r\n\r\n      <p>\r\n        At construction time the messages related to this lifeline\r\n        are not known. They will be added later by calls to \r\n        {@link Lifeline#createConnectionPoint}. Layout has to \r\n        be performed after all messages have been added.\r\n      </p>\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n    */\r\n    constructor(svg, id, lifelineDescription, style, log) {\r\n        super(svg, \"lifeline\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.svg = svg\r\n        this.lifelineDescription = lifelineDescription\r\n        this.style = style\r\n        this.log = log\r\n\r\n        this.lineTopPosition = { x: 0, y: 0 }\r\n        this.boxHeight = 0\r\n\r\n        // List of connection points that are connected to\r\n        // this lifeline\r\n        this.connectionPoints = [ ]\r\n        this.adjustmentNeeded = false\r\n        this.lifelineLayout = new _LifelineLayout_js__WEBPACK_IMPORTED_MODULE_3__[\"LifelineLayout\"]()\r\n    }\r\n\r\n    /**\r\n      <p>\r\n        Creates a new connection point. Connection points are used\r\n        to link lifelines and messages.\r\n      </p>\r\n\r\n      <p>\r\n        Calls to this functions are also used to communicate to\r\n        the lifeline which messages it receives or sends. The order\r\n        of the calls therefore matters as the order of the messages\r\n        is assumed to be the order in which this function is called.\r\n      </p>\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n      @param {string} type - The type of the message.\r\n      @returns {ConnectionPoint}\r\n    */\r\n    createConnectionPoint(svg, type) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPoint\"](svg, this)\r\n        this.connectionPoints.push({ point: newPoint, type: type })\r\n        return newPoint\r\n    }\r\n\r\n    getLineTopPosition() {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        return this.lineTopPosition\r\n    }\r\n\r\n    getFirstConnectionPointPosition() {\r\n        let position = this.getLineTopPosition()\r\n        position.y += (this.style.getExecutionSpecificationBarMargin() + this.style.getExecutionSpecificationBarOverhang())\r\n        return position\r\n    }\r\n\r\n    getCreationConnectionPointPosition() {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        return { x: this.x, y: (this.y + (this.boxHeight / 2)) }\r\n    }\r\n\r\n    getActiveLineWidth() {\r\n        return this.style.getExecutionSpecificationBarWidth()\r\n    }\r\n\r\n    getHorizontalOffset(y, side) {\r\n        let result = 0\r\n        if (side == \"right\") {\r\n            result = (this.lifelineLayout.getDepth(y) * (this.getActiveLineWidth() / 2))\r\n        } else if (side == \"left\") {\r\n            result = -(this.lifelineLayout.getDepth(y) * (this.getActiveLineWidth() / 2))\r\n        }\r\n        return result\r\n    }\r\n\r\n    needToAdjustDestructionPosition() {\r\n        if (this.connectionPoints.length > 1) {\r\n            if ((this.connectionPoints[this.connectionPoints.length - 1].type != \"return-start\") &&\r\n                (this.connectionPoints[this.connectionPoints.length - 1].type != \"creation-end\")) {\r\n                this.adjustmentNeeded = true\r\n            }\r\n        }\r\n        return this.adjustmentNeeded\r\n    }\r\n\r\n    doLayout() {\r\n        this.lifelineLayout.dolayout(this.connectionPoints, this.adjustmentNeeded)\r\n    }\r\n\r\n    doUpdate() {\r\n        this.log.info(\"Lifeline \" + this.id + \": updating\")\r\n        this.layers.clearEachLayer()\r\n        let lifelineGroup = this.shapeLayer.group().addClass(\"UMLLifeline\")\r\n\r\n        // The box need to be updated first because the position of the top of\r\n        // the line is computed as part of that update\r\n        updateBox(this, lifelineGroup, this.lifelineDescription, this.style, this.lineTopPosition)\r\n        updateLine(this, lifelineGroup, this.lifelineDescription, this.lifelineLayout.depthChanges, this.style)\r\n    }\r\n\r\n}\r\n\r\n// Create the box at the top of the lifeline\r\nfunction updateBox(self, lifelineGroup, lifelineDescription, style, lineTopPosition) {\r\n    let currentDimensions = { \r\n        width: 0,\r\n        height: 0\r\n    }\r\n\r\n    let borderAdjustment = {\r\n        top: self.y + 1,\r\n        left: self.x + 1\r\n    }\r\n\r\n    currentDimensions.height = style.getTopMargin(\"lifeline\")\r\n\r\n    var instanceNameGroup = self.textLayer.group().addClass(\"UMLInstanceName\")\r\n    var instanceNameDef = instanceNameGroup.text(\":\" + lifelineDescription.name).move(borderAdjustment.left + style.getLeftMargin(\"lifeline\"), borderAdjustment.top + currentDimensions.height)\r\n    currentDimensions.width = Math.max(currentDimensions.width, instanceNameDef.bbox().width)\r\n    currentDimensions.height += (instanceNameDef.bbox().height + style.getBottomMargin(\"lifeline\"))\r\n\r\n    currentDimensions.width += (style.getLeftMargin(\"lifeline\") + style.getRightMargin(\"lifeline\"))\r\n    \r\n    lifelineGroup.rect(currentDimensions.width, currentDimensions.height).move(borderAdjustment.left, borderAdjustment.top)\r\n    self.boxHeight = currentDimensions.height\r\n\r\n    lineTopPosition.x = (borderAdjustment.left + (currentDimensions.width / 2))\r\n    lineTopPosition.y = (borderAdjustment.top + currentDimensions.height)\r\n}\r\n\r\nfunction updateLine(self, lifelineGroup, lifelineDescription, depthChanges, style) {\r\n    let overhang = style.getExecutionSpecificationBarOverhang()\r\n\r\n    let debugMessage = \"Lifeline \" + self.id + \": depth changes: [\"\r\n    for (let depthChange of depthChanges) {\r\n         debugMessage += \" \" + depthChange[1]\r\n    }\r\n    debugMessage += \" ]\"\r\n    self.log.debug(debugMessage)\r\n\r\n    if (depthChanges.length == 1) {\r\n        if (depthChanges[0][1] > 0) {\r\n            lifelineGroup.line(self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0] - overhang)\r\n            lifelineGroup\r\n                .rect(8, (2 * overhang))\r\n                .move(self.lineTopPosition.x - 4, depthChanges[0][0] - overhang)\r\n        } else {\r\n             lifelineGroup.line(self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0])\r\n        }\r\n    } else if (depthChanges.length > 1) {\r\n        lifelineGroup.line(self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0] - overhang)\r\n        let maxDepth = 0\r\n        for (let depthChange of depthChanges) {\r\n            maxDepth = Math.max(maxDepth, depthChange[1])\r\n        }\r\n        let levelStart = [ ]\r\n        let layers = [ ]\r\n        for (let i = 0; i <= maxDepth; i++) {\r\n            levelStart.push(-1)\r\n            layers.push(new _SVGLayer_js__WEBPACK_IMPORTED_MODULE_2__[\"SVGLayer\"](self.svg))\r\n        }\r\n        for (let i = 1; i < depthChanges.length; i++) {\r\n\r\n            // At each iteration we try to process/draw the previous changes in\r\n            // depth: (i-1)\r\n\r\n            // The nesting level of the segment we are currently trying to draw\r\n            let currentNestingLevel = depthChanges[i-1][1]\r\n            let nextNestingLevel = depthChanges[i][1]\r\n\r\n            self.log.trace(\"Lifeline \" + self.id + \": handling depth change \" + i + \" from \" \r\n                + currentNestingLevel + \" to \" + nextNestingLevel)\r\n\r\n            if (currentNestingLevel == 0) {\r\n                // Segments outside any execution specification bar can always\r\n                // be drawn immediately since there isn't any nesting possible\r\n                // in that case\r\n                self.log.trace(\"Lifeline \" + self.id + \": drawing line\")\r\n                layers[currentNestingLevel].line(self.lineTopPosition.x, depthChanges[i-1][0], self.lineTopPosition.x, depthChanges[i][0])\r\n            } else if (nextNestingLevel > currentNestingLevel) {\r\n                // If the depth is increasing we need to hold off on drawing the\r\n                // previous segment since we are going to draw a nested execution\r\n                // specification bar, we store the start of the deferred segment\r\n                // for later use\r\n                self.log.trace(\"Lifeline \" + self.id + \": deferring drawing\")\r\n                levelStart[currentNestingLevel] = depthChanges[i-1][0]\r\n            } else if (nextNestingLevel <= currentNestingLevel) {\r\n                // If the depth stays the same it means we are at the end of the lifeline\r\n                // (remember we eliminate redundant points so the end of the lifeline is\r\n                // is the only case where we'd have two adjacent points of same depth)\r\n                \r\n                // If the depth is decreasing we can draw the segment since we are\r\n                // at the end of a nested or non-nested execution specification bar\r\n\r\n                self.log.trace(\"Lifeline \" + self.id + \": drawing rectangle\")\r\n\r\n                let start = depthChanges[i-1][0];\r\n                if (levelStart[currentNestingLevel] != -1) {\r\n                    start = levelStart[currentNestingLevel]\r\n                }\r\n\r\n                let offset = ((currentNestingLevel - 1) * 5)\r\n                layers[currentNestingLevel]\r\n                    .rect(8, (depthChanges[i][0] - start + (2 * overhang)))\r\n                    .move(self.lineTopPosition.x - 4 + offset, start - overhang)\r\n                levelStart[currentNestingLevel] = -1\r\n            }\r\n        }\r\n\r\n        // If the last change is an increase form 0 to 1 it means we have an\r\n        // isolated message right at the end of the lifeline which is not a\r\n        // destruction occurrence.\r\n        if ((depthChanges[depthChanges.length - 2][1] == 0) &&\r\n            (depthChanges[depthChanges.length - 1][1] > 0)) {\r\n            layers[depthChanges[depthChanges.length - 1][1]]\r\n                .rect(8, (2 * overhang))\r\n                .move(self.lineTopPosition.x - 4, depthChanges[depthChanges.length - 1][0] - overhang)\r\n        }\r\n       \r\n        // Since we are at the end of the line draw all the segments that are\r\n        // still deferred\r\n        let end = depthChanges[depthChanges.length - 1][0]\r\n        for (let i = 0; i < levelStart.length; i++) {\r\n            if (levelStart[i] != -1) {\r\n                layers[i]\r\n                    .rect(8, (end - levelStart[i] + (2 * overhang)))\r\n                    .move(self.lineTopPosition.x - 4, levelStart[i] - overhang)\r\n            }\r\n        }\r\n        for (let i = 0; i < layers.length; i++) {\r\n            layers[i].write(lifelineGroup)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Lifeline.js?");

/***/ }),

/***/ "./src/LifelineLayout.js":
/*!*******************************!*\
  !*** ./src/LifelineLayout.js ***!
  \*******************************/
/*! exports provided: LifelineLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LifelineLayout\", function() { return LifelineLayout; });\n\r\n\r\n/**\r\n  This class computes and stores the depth levels for the execution\r\n  specifications of the lifeline based on the messages received and\r\n  sent.\r\n*/\r\nclass LifelineLayout {\r\n\r\n    /**\r\n      Creates a new LifelineLayout instance.\r\n    */\r\n    constructor() {\r\n        this.depthChanges = [ ]\r\n    }\r\n\r\n    getDepth(y) {\r\n        let result = 0\r\n        let previous = -1\r\n        for (let i = 0; \r\n             ((i < this.depthChanges.length) && (y >= this.depthChanges[i][0]));\r\n             i++) {\r\n             result = this.depthChanges[i][1]\r\n             if (y > this.depthChanges[i][0]) {\r\n                 previous = i\r\n             } else {\r\n                 previous = (i-1)\r\n             }\r\n        }\r\n        if (previous >= 0) {\r\n            result = Math.max(result, this.depthChanges[previous][1])\r\n        }\r\n        return result\r\n    }\r\n\r\n    dolayout(connectionPoints, adjustmentNeeded) {\r\n        this.depthChanges.length = 0\r\n        for (let i = 0; i < connectionPoints.length; i++) {\r\n            let connectionPoint = connectionPoints[i]\r\n            switch (connectionPoint.type) {\r\n                case \"synchronous-start\":\r\n                    addCallerOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n\r\n                case \"synchronous-end\":\r\n                    addCalleeOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n\r\n                case \"return-start\":\r\n                    addReturnOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n\r\n                case \"return-end\":\r\n                    addReturnCalleeOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n\r\n                case \"creation-start\":\r\n                    addCallerOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n\r\n                case \"destruction-end\":\r\n                    if (adjustmentNeeded) {\r\n                        addReturnOccurrence(this.depthChanges, connectionPoint.point.y - 25)\r\n                    }\r\n                    addDestructionOccurrence(this.depthChanges, connectionPoint.point.y)\r\n                    break\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction addCallerOccurrence(depthChanges, y) {\r\n    depthChanges.push([y, 1])\r\n    concatenateLevels(depthChanges)\r\n}\r\n\r\nfunction addCalleeOccurrence(depthChanges, y) {\r\n    if (depthChanges.length == 0) {\r\n        depthChanges.push([y, 1])\r\n    } else {\r\n        depthChanges.push([y, depthChanges[depthChanges.length - 1][1] + 1])\r\n    }\r\n    concatenateLevels(depthChanges)\r\n}\r\n\r\nfunction addReturnOccurrence(depthChanges, y) {\r\n    let newLevel = 0\r\n    let length = depthChanges.length\r\n    if (length > 0) {\r\n        newLevel = Math.max(0, (depthChanges[length - 1][1] - 1))\r\n    }\r\n    depthChanges.push([y, newLevel])\r\n    concatenateLevels(depthChanges)\r\n}\r\n\r\nfunction addReturnCalleeOccurrence(depthChanges, y) {\r\n    let length = depthChanges.length\r\n    if (length == 0) {\r\n        depthChanges.push([y, 1])\r\n    } else {\r\n        depthChanges.push([y, depthChanges[length - 1][1]])\r\n    }\r\n    concatenateLevels(depthChanges)\r\n}\r\n\r\nfunction addDestructionOccurrence(depthChanges, y) {\r\n    depthChanges.push([y, 0])\r\n}\r\n\r\nfunction concatenateLevels(depthChanges) {\r\n    let length = depthChanges.length\r\n    if (length >= 3) {\r\n        if (depthChanges[length - 3][1] == depthChanges[length - 2][1]) {\r\n            depthChanges[length - 2][0] = depthChanges[length - 1][0]\r\n            depthChanges[length - 2][1] = depthChanges[length - 1][1]\r\n            depthChanges.pop()\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/LifelineLayout.js?");

/***/ }),

/***/ "./src/Log.js":
/*!********************!*\
  !*** ./src/Log.js ***!
  \********************/
/*! exports provided: Log */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Log\", function() { return Log; });\n\r\n\r\n/**\r\n  A class used to log diagram events, mostly useful\r\n  for debugging only.\r\n*/\r\nclass Log {\r\n\r\n    constructor(level) {\r\n        switch (level) {\r\n            case \"none\":\r\n                this.level = 0\r\n                break\r\n\r\n            case \"error\":\r\n                this.level = 1\r\n                break\r\n\r\n            case \"warn\":\r\n                this.level = 2\r\n                break\r\n\r\n            case \"info\":\r\n                this.level = 3\r\n                break\r\n\r\n            case \"debug\":\r\n                this.level = 4\r\n                break\r\n\r\n            case \"trace\":\r\n                this.level = 5\r\n                break\r\n        }\r\n    }\r\n\r\n    info(message) {\r\n        if (this.level >= 3) {\r\n            console.log(message)\r\n        }\r\n    }\r\n\r\n    debug(message) {\r\n        if (this.level >= 4) {\r\n            console.log(message)\r\n        }\r\n    }\r\n\r\n    trace(message) {\r\n        if (this.level >= 5) {\r\n            console.log(message)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Log.js?");

/***/ }),

/***/ "./src/Metrics.js":
/*!************************!*\
  !*** ./src/Metrics.js ***!
  \************************/
/*! exports provided: Metrics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Metrics\", function() { return Metrics; });\n\r\n\r\n/**\r\n  A class to collect metrics for performance\r\n  measurements.\r\n*/\r\nclass Metrics {\r\n\r\n    constructor() {\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Metrics.js?");

/***/ }),

/***/ "./src/Node.js":
/*!*********************!*\
  !*** ./src/Node.js ***!
  \*********************/
/*! exports provided: Node */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n/* harmony import */ var _Diagram_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Diagram.js */ \"./src/Diagram.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  A node on a deployment diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Node extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, nodeDescription, style) {\r\n        super(svg, \"node\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.nodeDescription = nodeDescription\r\n        this.style = style\r\n        this.connectionPointsRectangle = null\r\n    }\r\n\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPoint\"](svg, this)\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        var nodeGroup = this.shapeLayer.group().addClass(\"UMLNode\")\r\n    \r\n        let currentDimensions = { \r\n            width: 0,\r\n            height: 0\r\n        }\r\n\r\n        let borderAdjustment = {\r\n            top: this.y + 1,\r\n            left: this.x + 1\r\n        }\r\n    \r\n        currentDimensions.height = this.style.getTopMargin(\"node\")\r\n\r\n        let nodeNameGroup = this.textLayer.group().addClass(\"UMLNodeName\")\r\n        var nodeNameDef = nodeNameGroup.text(this.nodeDescription.name).move(borderAdjustment.left + this.style.getLeftMargin(\"node\"), borderAdjustment.top + currentDimensions.height + 10)\r\n        currentDimensions.width = Math.max(currentDimensions.width, nodeNameDef.bbox().width)\r\n        currentDimensions.height += (nodeNameDef.bbox().height + this.style.getBottomMargin(\"node\"))\r\n\r\n        if (currentDimensions.width > nodeNameDef.bbox().width) {\r\n            nodeNameDef.dx((currentDimensions.width - nodeNameDef.bbox().width)/2)\r\n        }\r\n\r\n        // A node can contain a sub-diagram inside it\r\n        if ((this.nodeDescription.elements != null) && (this.nodeDescription.elements.length > 0)) {\r\n            let diagram = new _Diagram_js__WEBPACK_IMPORTED_MODULE_2__[\"Diagram\"]()\r\n            diagram.createFromJSON(this.layers.svg, this.nodeDescription)\r\n        }\r\n\r\n        currentDimensions.width += (this.style.getLeftMargin(\"node\") + this.style.getRightMargin(\"node\"))\r\n\r\n        let pt1 = (borderAdjustment.left + 12) + \",\" + borderAdjustment.top\r\n        let pt2 = (borderAdjustment.left + currentDimensions.width + 10) + \",\" + borderAdjustment.top\r\n        let pt3 = (borderAdjustment.left + currentDimensions.width) + \",\" + (borderAdjustment.top + 10)\r\n        let pt4 = (borderAdjustment.left) + \",\" + (borderAdjustment.top + 10)\r\n        nodeGroup.polygon(pt1 + \" \" + pt2 + \" \" + pt3 + \" \" + pt4)\r\n\r\n        let pt5 = (borderAdjustment.left + currentDimensions.width) + \",\" + (borderAdjustment.top + currentDimensions.height + 10)\r\n        let pt6 = (borderAdjustment.left + currentDimensions.width + 10) + \",\" + (borderAdjustment.top + currentDimensions.height - 1)\r\n        nodeGroup.polygon(pt2 + \" \" + pt3 + \" \" + pt5 + \" \" + pt6)      \r\n\r\n        let rect = nodeGroup.rect(currentDimensions.width, currentDimensions.height).move(borderAdjustment.left, borderAdjustment.top + 10)\r\n\r\n        this.connectionPointsRectangle = rect.bbox()\r\n        this.connectionPointsRectangle.cy -= 5\r\n        this.connectionPointsRectangle.width += 5\r\n    }\r\n\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle \r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Node.js?");

/***/ }),

/***/ "./src/Note.js":
/*!*********************!*\
  !*** ./src/Note.js ***!
  \*********************/
/*! exports provided: Note */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Note\", function() { return Note; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n\r\n\r\n\r\n\r\n/**\r\n  A note on a UML diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Note extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, noteDescription, style) {\r\n        super(svg)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.id = id\r\n        this.noteDescription = noteDescription\r\n        this.style = style\r\n    }\r\n\r\n    update() {\r\n        this.uptodate = true\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Note.js?");

/***/ }),

/***/ "./src/SVGLayer.js":
/*!*************************!*\
  !*** ./src/SVGLayer.js ***!
  \*************************/
/*! exports provided: SVGLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SVGLayer\", function() { return SVGLayer; });\n\r\n\r\n/**\r\n  <p>\r\n    The SVG specification has no concept of layers. The \r\n    order in which elements are added to the image \r\n    dictate which ones will be shown over the others.\r\n    This is impractical so this class attempts to \r\n    provide a workaround.\r\n  </p>\r\n\r\n  <p>\r\n    Drawing will be first done on several layers. The\r\n    elements in each of the layers will then be added\r\n    to the SVG document layer per layer.\r\n  </p>   \r\n*/\r\nclass SVGLayer {\r\n\r\n    /**\r\n      Creates a new SVGLayer instance.\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n    */\r\n    constructor(svg) {\r\n        this.svg = svg\r\n        this.defs = [ ]\r\n    }\r\n\r\n    /**\r\n      Adds a group to the layer.\r\n\r\n      @returns {SVG.G} An SVG.G element as decribed in {@link http://svgjs.com/parents/#svg-g}\r\n    */\r\n    group() {\r\n        let groupDef = this.svg.defs().group()\r\n        this.defs.push(groupDef)\r\n        return groupDef\r\n    }\r\n\r\n    circle(radius) {\r\n        let circleDef = this.svg.defs().circle(radius)\r\n        this.defs.push(circleDef)\r\n        return circleDef\r\n    }\r\n\r\n    /**\r\n      Adds a line to the layer.\r\n\r\n      @returns {SVG.Line} An SVG.Line element as decribed in {@link http://svgjs.com/elements/#svg-line}\r\n    */\r\n    line(x1, y1, x2, y2) {\r\n        let lineDef = this.svg.defs().line(x1, y1, x2, y2)\r\n        this.defs.push(lineDef)\r\n        return lineDef\r\n    }\r\n\r\n    polygon(description) {\r\n        let polygonDef = this.svg.defs().polygon(description)\r\n        this.defs.push(polygonDef)\r\n        return polygonDef\r\n    }\r\n\r\n    /**\r\n      Adds a rectangle to the layer.\r\n\r\n      @returns {SVG.Rect} An SVG.Rect element as decribed in {@link http://svgjs.com/elements/#svg-rect}\r\n    */\r\n    rect(width, height) {\r\n        let rectDef = this.svg.defs().rect(width, height)\r\n        this.defs.push(rectDef)\r\n        return rectDef\r\n    }\r\n\r\n    /**\r\n      Adds a text element to the layer.\r\n\r\n      @returns {SVG.Text} An SVG.Text element as decribed in {@link http://svgjs.com/elements/#svg-text}\r\n    */\r\n    text(str) { \r\n        let textDef = this.svg.defs().text(str)\r\n        this.defs.push(textDef)\r\n        return textDef\r\n    }\r\n\r\n    /**\r\n      Writes the layer to the SVG document. This should be the final\r\n      action performed on the layer. In the current implementation there\r\n      is no way to undo the write.\r\n    */\r\n    write(container) {\r\n        let self = this\r\n        if (container == null) {\r\n            container = self.svg\r\n        }\r\n        self.defs.forEach(function(def) {\r\n            def.clone(container)\r\n            def.remove()\r\n        })\r\n    }\r\n\r\n    /**\r\n      Merges the contents of another layer into this layer.\r\n      The other layer should not be used afterwards.\r\n\r\n      @param {SVGLayer} layer - The contents of this layer will be merged\r\n        into this one.\r\n    */\r\n    merge(layer) {\r\n        this.defs = this.defs.concat(layer.defs)\r\n    }\r\n\r\n    /**\r\n      Remove all contents of the layer. Note that this doesn't\r\n      remove elements that have been written to the SVG document\r\n      already.\r\n    */\r\n    clear() {\r\n        let self = this\r\n        self.defs.forEach(function(def) {\r\n            def.remove()\r\n        })\r\n        self.defs.length = 0\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SVGLayer.js?");

/***/ }),

/***/ "./src/SVGLayerSet.js":
/*!****************************!*\
  !*** ./src/SVGLayerSet.js ***!
  \****************************/
/*! exports provided: SVGLayerSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SVGLayerSet\", function() { return SVGLayerSet; });\n/* harmony import */ var _SVGLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGLayer.js */ \"./src/SVGLayer.js\");\n\r\n\r\n\r\n\r\n/**\r\n  <p>\r\n    A set of layers.\r\n  </p>\r\n*/\r\nclass SVGLayerSet {\r\n\r\n    /**\r\n      Creates a new SVGLayerSet instance.\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n    */\r\n    constructor(svg) {\r\n        this.svg = svg\r\n        this.layers = { }\r\n    }\r\n\r\n    /**\r\n      Gets a layer.\r\n\r\n      @param {string} name - The name of the layer.\r\n      @returns {SVGLayer|null} The layer or null if no layer\r\n        with such name exists.\r\n    */\r\n    getLayer(name) {\r\n        return this.layers[name]\r\n    }\r\n\r\n    /**\r\n      Creates a new layer.\r\n\r\n      @param {string} name - The name of the layer.\r\n      @returns {SVGLayer} The new layer.\r\n    */\r\n    createLayer(name) {\r\n        let newLayer = new _SVGLayer_js__WEBPACK_IMPORTED_MODULE_0__[\"SVGLayer\"](this.svg)\r\n        this.layers[name] = newLayer\r\n        return newLayer\r\n    }\r\n\r\n    /**\r\n      Merge another set into this one. Layers\r\n      with the same name will be merged together\r\n      with the elements of the set given as argument\r\n      being appended.\r\n\r\n      @param {SVGLayerSet} layerSet - The other layer set.\r\n    */\r\n    merge(layerSet) {\r\n        let self = this\r\n        let keys = Object.keys(self.layers)\r\n        keys.forEach(function(key) {\r\n            self.layers[key].merge(layerSet.layers[key])\r\n        })\r\n    }\r\n\r\n    /**\r\n      Calls {@link SVGLayer#clear} on each layer in the set.\r\n    */\r\n    clearEachLayer() {\r\n        let self = this\r\n        let keys = Object.keys(self.layers)\r\n        keys.forEach(function(key) {\r\n            self.layers[key].clear()\r\n        })\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SVGLayerSet.js?");

/***/ }),

/***/ "./src/Settings.js":
/*!*************************!*\
  !*** ./src/Settings.js ***!
  \*************************/
/*! exports provided: Settings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Settings\", function() { return Settings; });\n\r\n\r\n/**\r\n  Diagram settings.\r\n\r\n  @property {int} width - The width of the diagram in pixels.\r\n  @property {height} height - The height of the diagram in pixels.\r\n  @property {boolean} debug - If debug is true then additional checks\r\n    and logging will be performed. This is false by default so that\r\n    diagrams are displayed as well as possible regardless\r\n    of errors. It is recommended to enable debug mode when updating a\r\n    diagram and set it back to false afterwards.\r\n*/\r\nclass Settings {\r\n\r\n    /** \r\n      Creates a new Settings instance with each property\r\n      having a default value or the value specified in \r\n      the jsonSettings argument.\r\n      @param {json=} jsonSettings - The initial settings.\r\n      @param {int} [jsonSettings.width=600] - The width of the diagram.\r\n      @param {int} [jsonSettings.height=200] - The height of the diagram.\r\n      @param {boolean} [jsonSettings.debug=false] - Debug mode.\r\n    */\r\n    constructor(jsonSettings) {\r\n        this.width = 600\r\n        this.height = 200\r\n        this.canMove = false\r\n        this.canResize = false\r\n        this.logLevel = \"none\"\r\n        this.debug = false\r\n\r\n        if (jsonSettings) {\r\n            if (jsonSettings.width) {\r\n                this.width = jsonSettings.width\r\n            }\r\n            if (jsonSettings.height) {\r\n                this.height = jsonSettings.height\r\n            }\r\n            if (jsonSettings.interactive) {\r\n                if (jsonSettings.interactive.canMove) {\r\n                    this.canMove = jsonSettings.interactive.canMove\r\n                }\r\n            }\r\n            if (jsonSettings.logLevel != null) {\r\n                this.logLevel = jsonSettings.logLevel\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Settings.js?");

/***/ }),

/***/ "./src/SocketConnector.js":
/*!********************************!*\
  !*** ./src/SocketConnector.js ***!
  \********************************/
/*! exports provided: SocketConnector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SocketConnector\", function() { return SocketConnector; });\n/* harmony import */ var _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGLayerSet.js */ \"./src/SVGLayerSet.js\");\n\r\n\r\n\r\n\r\nvar textDef = Symbol()\r\n\r\n/**\r\n  A socket connector to represent a dependency for a \r\n  component.\r\n*/\r\nclass SocketConnector {\r\n\r\n    constructor(svg, component, name) {\r\n        this.svg = svg\r\n        this.layers = new _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_0__[\"SVGLayerSet\"](svg)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.uptodate = false\r\n        this.x = 0\r\n        this.y = 0\r\n        this.component = component\r\n        this.name = name\r\n        this.textGroup = this.textLayer.group()\r\n        this[textDef] = this.textGroup.text(this.name).move(0, 0)\r\n        this.width = this[textDef].bbox().width + 5\r\n    }\r\n\r\n    getLayers() {\r\n        if (!this.uptodate) {\r\n            this.update()\r\n        }\r\n        return this.layers\r\n    }\r\n\r\n    // Move the connector so that the top left\r\n    // corner of the bounding box is at position\r\n    // (x, y)\r\n    move(x, y) {\r\n        this.uptodate = false\r\n        this.x = x\r\n        this.y = y\r\n    }\r\n\r\n    // Move the connector so that its connection\r\n    // point is at position (x, y)\r\n    moveConnectionPoint(x, y) {\r\n        this.uptodate = false\r\n        let connectorOffsetY = this[textDef].bbox().height + 6\r\n        y -= connectorOffsetY\r\n        this.move(x, y)\r\n    }\r\n\r\n    update() {\r\n        this.shapeLayer.clear()\r\n        this[textDef].move(this.x + 5, this.y)\r\n        let lineGroup = this.shapeLayer.group().addClass(\"UMLComponent\")\r\n        lineGroup.line(this.x, this.y + this[textDef].bbox().height + 8, this.x + (this.width / 2), this.y + this[textDef].bbox().height + 8)\r\n        let clippath = this.svg.clip()\r\n        clippath.rect(10, 17).move(this.x + (this.width / 2) - 1, this.y + this[textDef].bbox().height, 0)\r\n        lineGroup.circle(15).move(this.x + (this.width / 2), this.y + this[textDef].bbox().height + 1).clipWith(clippath)\r\n        this.uptodate = true\r\n    }\r\n\r\n    getAssemblyConnectionPoint() {\r\n        return { x: (this.x + (this.width / 2) - 1 + 10), y: this.y + this[textDef].bbox().height + 8 }\r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SocketConnector.js?");

/***/ }),

/***/ "./src/Style.js":
/*!**********************!*\
  !*** ./src/Style.js ***!
  \**********************/
/*! exports provided: Style */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Style\", function() { return Style; });\n\r\n\r\n/** Style settings. */\r\nclass Style {\r\n\r\n    constructor() {\r\n        this.style = {\r\n            \"defaults\": {\r\n                \"margin-left\": 12,\r\n                \"margin-right\": 12,\r\n                \"margin-top\": 9,\r\n                \"margin-bottom\": 9\r\n            },\r\n            \"classtemplate\": {\r\n                \"margin-right\": 15,\r\n                \"margin-top\": 12\r\n            },\r\n            \"classtemplateparameters\": {\r\n                \"margin-left\": 8,\r\n                \"margin-right\": 8,\r\n                \"margin-top\": 4,\r\n                \"margin-bottom\": 4\r\n            },\r\n            \"lifeline\": {\r\n                \"execution-specification-bar-width\": 8,\r\n                \"execution-specification-bar-overhang\": 5,\r\n                \"execution-specification-bar-margin\": 15\r\n            }\r\n        }\r\n    }\r\n\r\n    getTopMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-top\")\r\n    }\r\n\r\n    getBottomMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-bottom\")\r\n    }\r\n\r\n    getLeftMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-left\")\r\n    }\r\n\r\n    getRightMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-right\")\r\n    }\r\n\r\n    getExecutionSpecificationBarWidth() {\r\n        return this.style.lifeline[\"execution-specification-bar-width\"]\r\n    }\r\n\r\n    getExecutionSpecificationBarOverhang() {\r\n        return this.style.lifeline[\"execution-specification-bar-overhang\"]\r\n    }\r\n\r\n    getExecutionSpecificationBarMargin() {\r\n        return this.style.lifeline[\"execution-specification-bar-margin\"]\r\n    }\r\n\r\n    getValueOrDefault(self, element, style) {\r\n        if (self.style[element] && self.style[element][style]) {\r\n            return self.style[element][style]\r\n        } else {\r\n            return self.style[\"defaults\"][style]\r\n        }\r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Style.js?");

/***/ }),

/***/ "./src/UMLWebWidgetError.js":
/*!**********************************!*\
  !*** ./src/UMLWebWidgetError.js ***!
  \**********************************/
/*! exports provided: UMLWebWidgetError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UMLWebWidgetError\", function() { return UMLWebWidgetError; });\n\r\n\r\n/**\r\n  Errors related to diagram operations are\r\n  communicated via this class.\r\n\r\n  Note that by default errors are only shown\r\n  if debug mode is enabled in the {@link Settings}.\r\n*/\r\nclass UMLWebWidgetError extends Error {    \r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/UMLWebWidgetError.js?");

/***/ }),

/***/ "./src/UseCase.js":
/*!************************!*\
  !*** ./src/UseCase.js ***!
  \************************/
/*! exports provided: UseCase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UseCase\", function() { return UseCase; });\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n  A use case on a use case diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass UseCase extends _DiagramElement_js__WEBPACK_IMPORTED_MODULE_0__[\"DiagramElement\"] {\r\n\r\n    constructor(svg, id, useCaseDescription) {\r\n        super(svg, \"usecase\", id)\r\n        this.shapeLayer = this.layers.createLayer(\"shape\")\r\n        this.textLayer = this.layers.createLayer(\"text\")\r\n        this.useCaseDescription = useCaseDescription\r\n        this.connectionPointsRectangle = null\r\n    }\r\n\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"ConnectionPoint\"](svg, this)\r\n        return newPoint\r\n    }\r\n\r\n    doUpdate() {\r\n        let borderAdjustment = {\r\n            top: this.y,\r\n            left: this.x\r\n        }\r\n\r\n        let shapeGroup = this.shapeLayer.group().addClass(\"UMLUseCase\")\r\n        let textGroup = this.textLayer.group()\r\n        let textDef = textGroup.text(this.useCaseDescription.title)\r\n        let ellipse = shapeGroup.ellipse(1.2*textDef.bbox().width, 3*textDef.bbox().height).move(borderAdjustment.left + 1, borderAdjustment.top + 1)\r\n        textDef.move(borderAdjustment.left + 1 + 0.1*textDef.bbox().width, borderAdjustment.top + 1 + textDef.bbox().height)\r\n\r\n        this.connectionPointsRectangle = ellipse.bbox()\r\n    }\r\n\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle \r\n    }\r\n\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/UseCase.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: UMLWebWidgetError, Settings, Style, Diagram, DiagramElement, Connector, ConnectionPoint, ConnectionPointPosition, LayoutManager, ClassBox, ClassTemplate, Lifeline, LifelineLayout, Actor, UseCase, Component, Node, Note, SVGLayer, SVGLayerSet, Log, Metrics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _UMLWebWidgetError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UMLWebWidgetError.js */ \"./src/UMLWebWidgetError.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UMLWebWidgetError\", function() { return _UMLWebWidgetError_js__WEBPACK_IMPORTED_MODULE_0__[\"UMLWebWidgetError\"]; });\n\n/* harmony import */ var _Settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Settings.js */ \"./src/Settings.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Settings\", function() { return _Settings_js__WEBPACK_IMPORTED_MODULE_1__[\"Settings\"]; });\n\n/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Style.js */ \"./src/Style.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Style\", function() { return _Style_js__WEBPACK_IMPORTED_MODULE_2__[\"Style\"]; });\n\n/* harmony import */ var _Diagram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Diagram.js */ \"./src/Diagram.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Diagram\", function() { return _Diagram_js__WEBPACK_IMPORTED_MODULE_3__[\"Diagram\"]; });\n\n/* harmony import */ var _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConnectionPoint.js */ \"./src/ConnectionPoint.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPoint\", function() { return _ConnectionPoint_js__WEBPACK_IMPORTED_MODULE_4__[\"ConnectionPoint\"]; });\n\n/* harmony import */ var _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConnectionPointPosition.js */ \"./src/ConnectionPointPosition.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPointPosition\", function() { return _ConnectionPointPosition_js__WEBPACK_IMPORTED_MODULE_5__[\"ConnectionPointPosition\"]; });\n\n/* harmony import */ var _DiagramElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DiagramElement.js */ \"./src/DiagramElement.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DiagramElement\", function() { return _DiagramElement_js__WEBPACK_IMPORTED_MODULE_6__[\"DiagramElement\"]; });\n\n/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Connector.js */ \"./src/Connector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Connector\", function() { return _Connector_js__WEBPACK_IMPORTED_MODULE_7__[\"Connector\"]; });\n\n/* harmony import */ var _LayoutManager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LayoutManager.js */ \"./src/LayoutManager.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LayoutManager\", function() { return _LayoutManager_js__WEBPACK_IMPORTED_MODULE_8__[\"LayoutManager\"]; });\n\n/* harmony import */ var _LifelineLayout_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LifelineLayout.js */ \"./src/LifelineLayout.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LifelineLayout\", function() { return _LifelineLayout_js__WEBPACK_IMPORTED_MODULE_9__[\"LifelineLayout\"]; });\n\n/* harmony import */ var _ClassBox_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ClassBox.js */ \"./src/ClassBox.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ClassBox\", function() { return _ClassBox_js__WEBPACK_IMPORTED_MODULE_10__[\"ClassBox\"]; });\n\n/* harmony import */ var _ClassTemplate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ClassTemplate.js */ \"./src/ClassTemplate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ClassTemplate\", function() { return _ClassTemplate_js__WEBPACK_IMPORTED_MODULE_11__[\"ClassTemplate\"]; });\n\n/* harmony import */ var _Lifeline_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Lifeline.js */ \"./src/Lifeline.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Lifeline\", function() { return _Lifeline_js__WEBPACK_IMPORTED_MODULE_12__[\"Lifeline\"]; });\n\n/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Actor.js */ \"./src/Actor.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Actor\", function() { return _Actor_js__WEBPACK_IMPORTED_MODULE_13__[\"Actor\"]; });\n\n/* harmony import */ var _UseCase_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./UseCase.js */ \"./src/UseCase.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UseCase\", function() { return _UseCase_js__WEBPACK_IMPORTED_MODULE_14__[\"UseCase\"]; });\n\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _Component_js__WEBPACK_IMPORTED_MODULE_15__[\"Component\"]; });\n\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Node.js */ \"./src/Node.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return _Node_js__WEBPACK_IMPORTED_MODULE_16__[\"Node\"]; });\n\n/* harmony import */ var _Note_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Note.js */ \"./src/Note.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Note\", function() { return _Note_js__WEBPACK_IMPORTED_MODULE_17__[\"Note\"]; });\n\n/* harmony import */ var _SVGLayer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./SVGLayer.js */ \"./src/SVGLayer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SVGLayer\", function() { return _SVGLayer_js__WEBPACK_IMPORTED_MODULE_18__[\"SVGLayer\"]; });\n\n/* harmony import */ var _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./SVGLayerSet.js */ \"./src/SVGLayerSet.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SVGLayerSet\", function() { return _SVGLayerSet_js__WEBPACK_IMPORTED_MODULE_19__[\"SVGLayerSet\"]; });\n\n/* harmony import */ var _Log_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Log.js */ \"./src/Log.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Log\", function() { return _Log_js__WEBPACK_IMPORTED_MODULE_20__[\"Log\"]; });\n\n/* harmony import */ var _Metrics_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Metrics.js */ \"./src/Metrics.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Metrics\", function() { return _Metrics_js__WEBPACK_IMPORTED_MODULE_21__[\"Metrics\"]; });\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/index.js?");

/***/ })

/******/ });
});