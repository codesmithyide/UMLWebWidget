(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CodeSmithyUMLWebWidget"] = factory();
	else
		root["CodeSmithyUMLWebWidget"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Actor.ts":
/*!**********************!*\
  !*** ./src/Actor.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\n/**\r\n  An actor on a use case diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Actor extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, id, actorDescription, errors) {\r\n        super(svg, \"actor\", id);\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.actorDescription = actorDescription;\r\n        this.connectionPointsRectangle = null;\r\n    }\r\n    draw() {\r\n        this.update();\r\n        this.layers.getLayer(\"shape\").write();\r\n        this.layers.getLayer(\"text\").write();\r\n    }\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        let borderAdjustment = {\r\n            top: this.y,\r\n            left: this.x\r\n        };\r\n        let shapeGroup = this.shapeLayer.group().addClass(\"UMLActor\");\r\n        let textGroup = this.textLayer.group();\r\n        let textDef = textGroup.text(this.actorDescription.name).move(borderAdjustment.left, borderAdjustment.top + 35);\r\n        let width = textDef.bbox().width;\r\n        let offset = ((width - 16) / 2);\r\n        shapeGroup.circle(12).move(borderAdjustment.left + 2 + offset, borderAdjustment.top + 1);\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 13, borderAdjustment.left + 8 + offset, borderAdjustment.top + 26);\r\n        shapeGroup.line(borderAdjustment.left + offset, borderAdjustment.top + 18, borderAdjustment.left + 16 + offset, borderAdjustment.top + 18);\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 26, borderAdjustment.left + offset, borderAdjustment.top + 33);\r\n        shapeGroup.line(borderAdjustment.left + 8 + offset, borderAdjustment.top + 26, borderAdjustment.left + 16 + offset, borderAdjustment.top + 33);\r\n        this.connectionPointsRectangle = {\r\n            \"x\": borderAdjustment.left,\r\n            \"y\": borderAdjustment.top,\r\n            \"w\": width,\r\n            \"width\": width,\r\n            \"height\": (35 + textDef.bbox().height),\r\n            \"h\": (35 + textDef.bbox().height),\r\n            \"x2\": (borderAdjustment.left + width),\r\n            \"y2\": (borderAdjustment.top + 35 + textDef.bbox().height),\r\n            \"cx\": (borderAdjustment.left + (width / 2)),\r\n            \"cy\": (borderAdjustment.top + ((35 + textDef.bbox().height) / 2))\r\n        };\r\n    }\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle;\r\n    }\r\n}\r\nexports.Actor = Actor;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Actor.ts?");

/***/ }),

/***/ "./src/BallConnector.ts":
/*!******************************!*\
  !*** ./src/BallConnector.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGLayerSet_1 = __webpack_require__(/*! ./SVGLayerSet */ \"./src/SVGLayerSet.ts\");\r\nvar textDef = Symbol();\r\n/**\r\n  A ball connector to represent an interface for a\r\n  component.\r\n*/\r\nclass BallConnector {\r\n    constructor(svg, component, name) {\r\n        this.svg = svg;\r\n        this.layers = new SVGLayerSet_1.SVGLayerSet(svg);\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.uptodate = false;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.component = component;\r\n        this.name = name;\r\n        this.textGroup = this.textLayer.group();\r\n        this[textDef] = this.textGroup.text(this.name).move(0, 0);\r\n        this.width = this[textDef].bbox().width + 5;\r\n    }\r\n    getLayers() {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        return this.layers;\r\n    }\r\n    // Move the connector so that the top left\r\n    // corner of the bounding box is at position\r\n    // (x, y)\r\n    move(x, y) {\r\n        this.uptodate = false;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // Move the connector so that its connection\r\n    // point is at position (x, y)\r\n    moveConnectionPoint(x, y) {\r\n        this.uptodate = false;\r\n        let connectorOffsetY = this[textDef].bbox().height + 3;\r\n        y -= connectorOffsetY;\r\n        this.move(x, y);\r\n    }\r\n    update() {\r\n        this.shapeLayer.clear();\r\n        this[textDef].move(this.x, this.y);\r\n        let lineGroup = this.shapeLayer.group().addClass(\"UMLComponent\");\r\n        lineGroup.circle(10).move(this.x + (this.width) / 2 - 5, this.y + 22);\r\n        lineGroup.line(this.x + 10 + (this.width) / 2 - 5, this.y + 27, this.x + (this.width), this.y + 27);\r\n    }\r\n    getAssemblyConnectionPoint() {\r\n        return { x: (this.x + (this.width / 2) - 4), y: this.y + this[textDef].bbox().height + 5 };\r\n    }\r\n}\r\nexports.BallConnector = BallConnector;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/BallConnector.ts?");

/***/ }),

/***/ "./src/ClassBox.ts":
/*!*************************!*\
  !*** ./src/ClassBox.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nconst DrawingUtilities_1 = __webpack_require__(/*! ./DrawingUtilities */ \"./src/DrawingUtilities.ts\");\r\nconst SVGUtils_1 = __webpack_require__(/*! ./SVGUtils */ \"./src/SVGUtils.ts\");\r\n/**\r\n * A class box.\r\n *\r\n * @extends DiagramElement\r\n * @property {ConnectionPoint[]} this.connectionPoints - The class keeps a list of connection points where other\r\n * elements are connected so they can be notified of relevant changes to the class box.\r\n */\r\nclass ClassBox extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, idGenerator, classDescription, canMove, style, errors) {\r\n        super(svg, \"class-box\" /* ClassBox */, idGenerator.createID(\"class-box--\" + classDescription.name));\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.classDescription = classDescription;\r\n        this.canMove = canMove;\r\n        this.style = style;\r\n        this.connectionPointsRectangle = null;\r\n        // List of connection points that are connected to this class box\r\n        this.connectionPoints = [];\r\n    }\r\n    draw() {\r\n        this.update();\r\n        let g = this.layers.svg.group().addClass(\"class-box\" /* ClassBox */);\r\n        g.id(this.id);\r\n        this.layers.getLayer(\"shape\").write(g);\r\n        this.layers.getLayer(\"text\").write(g);\r\n    }\r\n    /**\r\n     * Returns a connection point that can be used to connect a connector to this class box. The new connection point is\r\n     * added to this.connectionPoints.\r\n     */\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        this.connectionPoints.push(newPoint);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        createDef(this, this.classDescription, this.canMove, this.style);\r\n    }\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle;\r\n    }\r\n    fire(evt) {\r\n        if (evt == \"positionchanged\") {\r\n            for (let i = 0; i < this.connectionPoints.length; i++) {\r\n                this.connectionPoints[i].draw();\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.ClassBox = ClassBox;\r\nfunction createDef(self, classInfo, canMove, style) {\r\n    var classGroup = self.shapeLayer.group().addClass(\"class-box__shape\" /* ClassBox_Shape */);\r\n    let currentDimensions = {\r\n        width: 0,\r\n        height: 0\r\n    };\r\n    let borderAdjustment = {\r\n        top: self.y + 1,\r\n        left: self.x + 1\r\n    };\r\n    currentDimensions.height = style.getTopMargin(\"class-box\" /* ClassBox */);\r\n    var classNameGroup = self.textLayer.group().addClass(\"class-box__class-name-compartment\" /* ClassBox_ClassNameCompartment */);\r\n    var className = SVGUtils_1.SVGUtils.Text(classNameGroup, borderAdjustment.left + style.getLeftMargin(\"class-box\" /* ClassBox */), borderAdjustment.top + currentDimensions.height, classInfo.name);\r\n    currentDimensions.width = Math.max(currentDimensions.width, className.bbox().width);\r\n    currentDimensions.height += (className.bbox().height + style.getBottomMargin(\"class-box\" /* ClassBox */));\r\n    var line1YPos = (borderAdjustment.top + currentDimensions.height);\r\n    let attributesCompartmentDimensions = DrawingUtilities_1.DrawingUtilities.addClassCompartmentText(borderAdjustment.left, line1YPos, self.textLayer, style, classInfo.attributes, \"class-box__attributes-compartment\" /* ClassBox_AttributesCompartment */);\r\n    currentDimensions.width = Math.max(currentDimensions.width, attributesCompartmentDimensions.width);\r\n    currentDimensions.height += attributesCompartmentDimensions.height;\r\n    var line2YPos = (borderAdjustment.top + currentDimensions.height);\r\n    let operationsCompartmentDimensions = DrawingUtilities_1.DrawingUtilities.addClassCompartmentText(borderAdjustment.left, line2YPos, self.textLayer, style, classInfo.operations, \"class-box__operations-compartment\" /* ClassBox_OperationsCompartment */);\r\n    currentDimensions.width = Math.max(currentDimensions.width, operationsCompartmentDimensions.width);\r\n    currentDimensions.height += operationsCompartmentDimensions.height;\r\n    // According to the UML standard the class name must be centered so center it\r\n    if (currentDimensions.width > className.bbox().width) {\r\n        className.dx((currentDimensions.width - className.bbox().width) / 2);\r\n    }\r\n    currentDimensions.width += (style.getLeftMargin(\"class-box\" /* ClassBox */) + style.getRightMargin(\"class-box\" /* ClassBox */));\r\n    let rect = SVGUtils_1.SVGUtils.Rectangle(classGroup, borderAdjustment.left, borderAdjustment.top, currentDimensions.width, currentDimensions.height);\r\n    SVGUtils_1.SVGUtils.Line(classGroup, borderAdjustment.left, line1YPos, borderAdjustment.left + currentDimensions.width, line1YPos);\r\n    SVGUtils_1.SVGUtils.Line(classGroup, borderAdjustment.left, line2YPos, borderAdjustment.left + currentDimensions.width, line2YPos);\r\n    self.connectionPointsRectangle = rect.bbox();\r\n    if (canMove) {\r\n        classGroup.draggable(true);\r\n        classGroup.on('dragmove.namespace', function (evt) {\r\n            self.fire('positionchanged');\r\n        });\r\n        classGroup.on('dragend.namespace', function (evt) {\r\n            self.fire('positionchanged');\r\n        });\r\n    }\r\n    return classGroup;\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ClassBox.ts?");

/***/ }),

/***/ "./src/ClassTemplate.ts":
/*!******************************!*\
  !*** ./src/ClassTemplate.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nconst DrawingUtilities_1 = __webpack_require__(/*! ./DrawingUtilities */ \"./src/DrawingUtilities.ts\");\r\nconst SVGUtils_1 = __webpack_require__(/*! ./SVGUtils */ \"./src/SVGUtils.ts\");\r\nclass ClassTemplate extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, idGenerator, classTemplateDescription, style, errors) {\r\n        super(svg, \"class-template\" /* ClassTemplate */, idGenerator.createID(\"class-template--\" + classTemplateDescription.name));\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.classTemplateDescription = classTemplateDescription;\r\n        this.style = style;\r\n        this.connectionPointsRectangle = null;\r\n        // List of connection points that are connected to\r\n        // this class template\r\n        this.connectionPoints = [];\r\n    }\r\n    draw() {\r\n        this.update();\r\n        let g = this.layers.svg.group().addClass(\"class-template\" /* ClassTemplate */);\r\n        g.id(this.id);\r\n        this.layers.getLayer(\"shape\").write(g);\r\n        this.layers.getLayer(\"text\").write(g);\r\n    }\r\n    /**\r\n     * Returns a connection point that can be used to connect a connector to this class template. The new connection\r\n     * point is added to this.connectionPoints.\r\n     */\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        this.connectionPoints.push(newPoint);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        var classTemplateGroup = this.shapeLayer.group().addClass(\"class-template__shape\" /* ClassTemplate_Shape */);\r\n        let currentDimensions = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        let borderAdjustment = {\r\n            top: this.y + 1,\r\n            left: this.x + 1\r\n        };\r\n        var parametersTextGroup = this.textLayer.group().addClass(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */);\r\n        var parametersText = SVGUtils_1.SVGUtils.Text(parametersTextGroup, borderAdjustment.left + this.style.getLeftMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */), borderAdjustment.top + this.style.getTopMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */), this.classTemplateDescription.parameters[0]);\r\n        let parametersRectWidth = (this.style.getLeftMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */) + this.style.getRightMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */) + parametersText.bbox().width);\r\n        let parametersRectHeight = (this.style.getTopMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */) + this.style.getBottomMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */) + parametersText.bbox().height);\r\n        let y1 = (borderAdjustment.top + this.style.getTopMargin(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */) + (parametersText.bbox().height / 2));\r\n        let y2 = (y1 + this.style.getTopMargin(\"class-template\" /* ClassTemplate */));\r\n        let classTemplateNameGroup = this.textLayer.group().addClass(\"class-template__class-name-compartment\" /* ClassTemplate_ClassNameCompartment */);\r\n        let classTemplateName = SVGUtils_1.SVGUtils.Text(classTemplateNameGroup, borderAdjustment.left + this.style.getLeftMargin(\"class-template\" /* ClassTemplate */), y2, this.classTemplateDescription.name);\r\n        currentDimensions.width = Math.max(currentDimensions.width, classTemplateName.bbox().width);\r\n        currentDimensions.height = (this.style.getTopMargin(\"class-template\" /* ClassTemplate */) + classTemplateName.bbox().height + this.style.getBottomMargin(\"class-template\" /* ClassTemplate */));\r\n        let line1YPos = (borderAdjustment.top + currentDimensions.height + (parametersText.bbox().height / 2));\r\n        let attributesCompartmentDimensions = DrawingUtilities_1.DrawingUtilities.addClassCompartmentText(borderAdjustment.left, line1YPos, this.textLayer, this.style, this.classTemplateDescription.attributes, \"class-template__attributes-compartment\" /* ClassTemplate_AttributesCompartment */);\r\n        currentDimensions.width = Math.max(currentDimensions.width, attributesCompartmentDimensions.width);\r\n        currentDimensions.height += attributesCompartmentDimensions.height;\r\n        let line2YPos = (borderAdjustment.top + currentDimensions.height + (parametersText.bbox().height / 2));\r\n        let operationsCompartmentDimensions = DrawingUtilities_1.DrawingUtilities.addClassCompartmentText(borderAdjustment.left, line2YPos, this.textLayer, this.style, this.classTemplateDescription.operations, \"class-template__operations-compartment\" /* ClassTemplate_OperationsCompartment */);\r\n        currentDimensions.width = Math.max(currentDimensions.width, operationsCompartmentDimensions.width);\r\n        currentDimensions.height += operationsCompartmentDimensions.height;\r\n        // According to the UML standard the class name must be centered so center it\r\n        if (currentDimensions.width > classTemplateName.bbox().width) {\r\n            classTemplateName.dx((currentDimensions.width - classTemplateName.bbox().width) / 2);\r\n        }\r\n        currentDimensions.width += (this.style.getLeftMargin(\"class-template\" /* ClassTemplate */) + this.style.getRightMargin(\"class-template\" /* ClassTemplate */));\r\n        let rect = SVGUtils_1.SVGUtils.Rectangle(classTemplateGroup, borderAdjustment.left, y1, currentDimensions.width, currentDimensions.height);\r\n        SVGUtils_1.SVGUtils.Line(classTemplateGroup, borderAdjustment.left, line1YPos, borderAdjustment.left + currentDimensions.width, line1YPos);\r\n        SVGUtils_1.SVGUtils.Line(classTemplateGroup, borderAdjustment.left, line2YPos, borderAdjustment.left + currentDimensions.width, line2YPos);\r\n        parametersText.dx(currentDimensions.width - (parametersRectWidth / 2));\r\n        let parametersRect = SVGUtils_1.SVGUtils.Rectangle(classTemplateGroup, borderAdjustment.left + currentDimensions.width - (parametersRectWidth / 2), borderAdjustment.top, parametersRectWidth, parametersRectHeight).attr(\"stroke-dasharray\", \"4, 4\");\r\n        this.connectionPointsRectangle = rect.bbox();\r\n    }\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle;\r\n    }\r\n}\r\nexports.ClassTemplate = ClassTemplate;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ClassTemplate.ts?");

/***/ }),

/***/ "./src/Component.ts":
/*!**************************!*\
  !*** ./src/Component.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst BallConnector_1 = __webpack_require__(/*! ./BallConnector */ \"./src/BallConnector.ts\");\r\nconst SocketConnector_1 = __webpack_require__(/*! ./SocketConnector */ \"./src/SocketConnector.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nclass Stereotype {\r\n    constructor(svgParentGroup) {\r\n        this.svgParentGroup = svgParentGroup;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 15;\r\n        this.height = 20;\r\n    }\r\n    move(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    draw() {\r\n        let stereoTypeGroup = this.svgParentGroup.group().addClass(\"UMLComponentStereotype\");\r\n        stereoTypeGroup.rect(11, 15).move(4 + this.x, this.y);\r\n        stereoTypeGroup.rect(8, 3).move(this.x, this.y + 3);\r\n        stereoTypeGroup.rect(8, 3).move(this.x, this.y + 9);\r\n    }\r\n}\r\n/**\r\n * A component on a component diagram.\r\n *\r\n * @extends DiagramElement\r\n */\r\nclass Component extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, id, componentDescription, style, errors) {\r\n        super(svg, \"component\", id);\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.svg = svg;\r\n        this.componentDescription = componentDescription;\r\n        this.style = style;\r\n        this.ballConnectors = [];\r\n        this.socketConnectors = [];\r\n        if (this.componentDescription.interfaces) {\r\n            for (let i = 0; i < this.componentDescription.interfaces.length; i++) {\r\n                let ballConnector = new BallConnector_1.BallConnector(this.svg, this, this.componentDescription.interfaces[i].name);\r\n                this.ballConnectors.push(ballConnector);\r\n            }\r\n        }\r\n        if (this.componentDescription.dependencies) {\r\n            for (let i = 0; i < this.componentDescription.dependencies.length; i++) {\r\n                let socketConnector = new SocketConnector_1.SocketConnector(this.svg, this, this.componentDescription.dependencies[i].name);\r\n                this.socketConnectors.push(socketConnector);\r\n            }\r\n        }\r\n    }\r\n    draw() {\r\n        this.update();\r\n        this.layers.getLayer(\"shape\").write();\r\n        this.layers.getLayer(\"text\").write();\r\n    }\r\n    getSocketConnector(name) {\r\n        for (var i = 0; i < this.socketConnectors.length; i++) {\r\n            if (this.socketConnectors[i].name == name) {\r\n                return this.socketConnectors[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getBallConnector(name) {\r\n        for (var i = 0; i < this.ballConnectors.length; i++) {\r\n            if (this.ballConnectors[i].name == name) {\r\n                return this.ballConnectors[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    createDependencyConnectionPoint(svg, interfaceName) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this.getSocketConnector(interfaceName), ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        return newPoint;\r\n    }\r\n    createInterfaceConnectionPoint(svg, interfaceName) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this.getBallConnector(interfaceName), ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        this.layers.clearEachLayer();\r\n        var componentGroup = this.shapeLayer.group().addClass(\"UMLComponent\");\r\n        let offset = 0;\r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            offset = Math.max(offset, this.ballConnectors[i].width);\r\n        }\r\n        let position = {\r\n            x: this.x + 1,\r\n            y: this.y + 1\r\n        };\r\n        let currentDimensions = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        currentDimensions.height = this.style.getTopMargin(\"component\");\r\n        let stereotype = new Stereotype(componentGroup);\r\n        currentDimensions.height += stereotype.height;\r\n        var componentNameGroup = this.textLayer.group().addClass(\"UMLComponentName\");\r\n        var componentNameDef = componentNameGroup.text(this.componentDescription.name).addClass(\"UMLComponentName\").move(position.x + offset + this.style.getLeftMargin(\"component\"), position.y + currentDimensions.height);\r\n        currentDimensions.width = Math.max(currentDimensions.width, componentNameDef.bbox().width);\r\n        currentDimensions.height += (componentNameDef.bbox().height + this.style.getBottomMargin(\"component\"));\r\n        currentDimensions.width += (this.style.getLeftMargin(\"component\") + this.style.getRightMargin(\"component\"));\r\n        componentGroup.rect(currentDimensions.width, currentDimensions.height).move(position.x + offset, position.y);\r\n        stereotype.move(position.x + offset + (currentDimensions.width - this.style.getRightMargin(\"component\") - stereotype.width), position.y + this.style.getTopMargin(\"component\"));\r\n        stereotype.draw();\r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            this.ballConnectors[i].moveConnectionPoint(position.x, position.y + currentDimensions.height / 2);\r\n            this.layers.merge(this.ballConnectors[i].getLayers());\r\n        }\r\n        for (let i = 0; i < this.socketConnectors.length; i++) {\r\n            this.socketConnectors[i].moveConnectionPoint(position.x + currentDimensions.width + offset, position.y + currentDimensions.height / 2);\r\n            this.layers.merge(this.socketConnectors[i].getLayers());\r\n        }\r\n    }\r\n    getBallConnectionPoint(name) {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        for (let i = 0; i < this.ballConnectors.length; i++) {\r\n            return this.ballConnectors[i].getAssemblyConnectionPoint();\r\n        }\r\n    }\r\n    getSocketConnectionPoint(name) {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        for (let i = 0; i < this.socketConnectors.length; i++) {\r\n            return this.socketConnectors[i].getAssemblyConnectionPoint();\r\n        }\r\n    }\r\n}\r\nexports.Component = Component;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Component.ts?");

/***/ }),

/***/ "./src/ConnectionPoint.ts":
/*!********************************!*\
  !*** ./src/ConnectionPoint.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\n/**\r\n * <p>\r\n *   The point where an element and a connector meet.\r\n * </p>\r\n *\r\n * <p>\r\n *   Although it derives from {@link DiagramElement} this element will probably be invisible to the user. However it may\r\n *   be useful to make the connection points visible under some circumstances like for instance when the diagram is\r\n *   being edited. </p>\r\n *\r\n *   @extends DiagramElement\r\n *   @property {DiagramElement} this.element - The element.\r\n *   @property {ConnectionPointPosition} this.position - The position of the connection point relative to the element.\r\n*/\r\nclass ConnectionPoint extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, element, position, errors) {\r\n        super(svg, \"connectionpoint\" /* ConnectionPoint */, null);\r\n        this.errors = errors;\r\n        this.element = element;\r\n        this.position = position;\r\n    }\r\n    setPosition(position) {\r\n        this.position = position;\r\n        let x = 0;\r\n        let y = 0;\r\n        let boundingbox = this.element.getConnectionPointsRectangle();\r\n        if (boundingbox != null) {\r\n            switch (this.position) {\r\n                case ConnectionPointPosition_1.ConnectionPointPosition.TopCenter:\r\n                    x = boundingbox.cx;\r\n                    y = boundingbox.y;\r\n                    break;\r\n                case ConnectionPointPosition_1.ConnectionPointPosition.RightCenter:\r\n                    x = (boundingbox.x + boundingbox.width);\r\n                    y = boundingbox.cy;\r\n                    break;\r\n                case ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter:\r\n                    x = boundingbox.cx;\r\n                    y = (boundingbox.y + boundingbox.height);\r\n                    break;\r\n                case ConnectionPointPosition_1.ConnectionPointPosition.LeftCenter:\r\n                    x = boundingbox.x;\r\n                    y = boundingbox.cy;\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            this.errors.assertDebug(false);\r\n        }\r\n        this.move(x, y);\r\n    }\r\n}\r\nexports.ConnectionPoint = ConnectionPoint;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ConnectionPoint.ts?");

/***/ }),

/***/ "./src/ConnectionPointPosition.ts":
/*!****************************************!*\
  !*** ./src/ConnectionPointPosition.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * The position of a connection point. These are not the coordinates of the connection point but a description of where\r\n * the connection point should be relative to the element.\r\n */\r\nclass ConnectionPointPosition {\r\n    constructor(type) {\r\n        switch (type) {\r\n            case \"top-center\":\r\n                this.type = topCenter;\r\n                break;\r\n            case \"top-right\":\r\n                this.type = topRight;\r\n                break;\r\n            case \"right-center\":\r\n                this.type = rightCenter;\r\n                break;\r\n            case \"bottom-right\":\r\n                this.type = bottomRight;\r\n                break;\r\n            case \"bottom-center\":\r\n                this.type = bottomCenter;\r\n                break;\r\n            case \"bottom-left\":\r\n                this.type = bottomLeft;\r\n                break;\r\n            case \"left-center\":\r\n                this.type = leftCenter;\r\n                break;\r\n            case \"top-left\":\r\n                this.type = topLeft;\r\n                break;\r\n        }\r\n    }\r\n    equals(other) {\r\n        return (this.type === other.type);\r\n    }\r\n    static get TopCenter() {\r\n        return staticTopCenter;\r\n    }\r\n    static get TopRight() {\r\n        return staticTopRight;\r\n    }\r\n    static get RightCenter() {\r\n        return staticRightCenter;\r\n    }\r\n    static get BottomRight() {\r\n        return staticBottomRight;\r\n    }\r\n    static get BottomCenter() {\r\n        return staticBottomCenter;\r\n    }\r\n    static get BottomLeft() {\r\n        return staticBottomLeft;\r\n    }\r\n    static get LeftCenter() {\r\n        return staticLeftCenter;\r\n    }\r\n    static get TopLeft() {\r\n        return staticTopLeft;\r\n    }\r\n}\r\nexports.ConnectionPointPosition = ConnectionPointPosition;\r\nlet topCenter = 0;\r\nlet topRight = 1;\r\nlet rightCenter = 2;\r\nlet bottomRight = 3;\r\nlet bottomCenter = 4;\r\nlet bottomLeft = 5;\r\nlet leftCenter = 6;\r\nlet topLeft = 7;\r\nlet staticTopCenter = new ConnectionPointPosition(\"top-center\");\r\nlet staticTopRight = new ConnectionPointPosition(\"top-right\");\r\nlet staticRightCenter = new ConnectionPointPosition(\"right-center\");\r\nlet staticBottomRight = new ConnectionPointPosition(\"bottom-right\");\r\nlet staticBottomCenter = new ConnectionPointPosition(\"bottom-center\");\r\nlet staticBottomLeft = new ConnectionPointPosition(\"bottom-left\");\r\nlet staticLeftCenter = new ConnectionPointPosition(\"left-center\");\r\nlet staticTopLeft = new ConnectionPointPosition(\"top-left\");\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/ConnectionPointPosition.ts?");

/***/ }),

/***/ "./src/Connector.ts":
/*!**************************!*\
  !*** ./src/Connector.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nconst Label_1 = __webpack_require__(/*! ./Label */ \"./src/Label.ts\");\r\nconst SVGUtils_1 = __webpack_require__(/*! ./SVGUtils */ \"./src/SVGUtils.ts\");\r\n/**\r\n  Represents a connector between elements.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Connector extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, type, connectionPoint1, connectionPoint2, text) {\r\n        super(svg, type, null);\r\n        this.setType(type);\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.connectionPoint1 = connectionPoint1;\r\n        this.connectionPoint2 = connectionPoint2;\r\n        this.label = null;\r\n        if (text != null) {\r\n            this.label = new Label_1.Label(text);\r\n        }\r\n        if ((this.label == null) && (type == \"creationmessage\" /* CreationMessageConnector */)) {\r\n            this.label = new Label_1.Label(\"new\");\r\n        }\r\n    }\r\n    draw() {\r\n        this.update();\r\n        switch (this.type) {\r\n            case \"inheritance\" /* InheritanceConnector */:\r\n            case \"composition\" /* CompositionConnector */:\r\n            case \"aggregation\" /* AggregationConnector */:\r\n                let g = this.layers.svg.group().addClass(this.cssParentGroupClass);\r\n                g.id(this.id);\r\n                this.layers.getLayer(\"shape\").write(g);\r\n                this.layers.getLayer(\"text\").write(g);\r\n                break;\r\n            default:\r\n                this.layers.getLayer(\"shape\").write();\r\n                this.layers.getLayer(\"text\").write();\r\n                break;\r\n        }\r\n    }\r\n    hasNonEmptyLabel() {\r\n        return ((this.label != null) && !this.label.empty());\r\n    }\r\n    doUpdate() {\r\n        this.layers.clearEachLayer();\r\n        if (this.type == \"inheritance\" /* InheritanceConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"connector__shape\" /* ConnectorShape */);\r\n            drawInheritanceRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"composition\" /* CompositionConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"connector__shape\" /* ConnectorShape */);\r\n            drawCompositionOrAggregationRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"aggregation\" /* AggregationConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"connector__shape\" /* ConnectorShape */);\r\n            drawCompositionOrAggregationRelationship(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"synchronousmessage\" /* SynchronousMessageConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLSynchronousMessage\");\r\n            let textGroup = null;\r\n            if ((this.label != null) && (this.label.text != null) && (this.label.text != \"\")) {\r\n                textGroup = this.textLayer.group();\r\n            }\r\n            drawSynchronousMessage(lineGroup, textGroup, this.connectionPoint1, this.connectionPoint2, this.label);\r\n        }\r\n        else if (this.type == \"returnmessage\" /* ReturnMessageConnector */) {\r\n            // If this is return message of a self call draw nothing. It will be indicated on the diagram by a reduction\r\n            // of the depth of the execution specification (i.e. the width of the lifeline)\r\n            if ((this.connectionPoint1.element != null) && (this.connectionPoint1.element != this.connectionPoint2.element)) {\r\n                let lineGroup = this.shapeLayer.group().addClass(\"UMLReturnMessage\");\r\n                drawReturnMessage(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n            }\r\n        }\r\n        else if (this.type == \"creationmessage\" /* CreationMessageConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLCreationMessage\");\r\n            let textGroup = this.textLayer.group();\r\n            drawSynchronousMessage(lineGroup, textGroup, this.connectionPoint1, this.connectionPoint2, this.label);\r\n        }\r\n        else if (this.type == \"destructionmessage\" /* DestructionMessageConnector */) {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLDestructionMessage\");\r\n            drawDestructionMessage(lineGroup, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"usecaseassociation\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLUseCaseAssociation\");\r\n            drawUseCaseAssociation(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"assemblyconnector\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLAssemblyConnector\");\r\n            drawAssemblyConnector(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n        else if (this.type == \"communicationpath\") {\r\n            let lineGroup = this.shapeLayer.group().addClass(\"UMLCommunicationPath\");\r\n            drawCommunicationPath(lineGroup, this.connectionPoint1, this.connectionPoint2);\r\n        }\r\n    }\r\n    setType(type) {\r\n        switch (type) {\r\n            case \"inheritance\" /* InheritanceConnector */:\r\n                this.cssParentGroupClass = \"connector connector--inheritance\" /* InheritanceConnector */;\r\n                break;\r\n            case \"composition\" /* CompositionConnector */:\r\n                this.cssParentGroupClass = \"connector connector--composition\" /* CompositionConnector */;\r\n                break;\r\n            case \"aggregation\" /* AggregationConnector */:\r\n                this.cssParentGroupClass = \"connector connector--aggregation\" /* AggregationConnector */;\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.Connector = Connector;\r\n// Draws an inheritance connector between two classes\r\nfunction drawInheritanceRelationship(lineGroup, connectionPoint1, connectionPoint2) {\r\n    let connectorOrientation = getConnectorHeadOrientationFromPosition(connectionPoint2.position);\r\n    let lineConnectionPoint = getInheritanceArrowLineConnectionPoint(connectionPoint2, connectorOrientation);\r\n    drawConnectorLine(lineGroup, connectionPoint1, lineConnectionPoint, connectorOrientation);\r\n    drawInheritanceArrow(lineGroup, connectionPoint2, connectorOrientation);\r\n}\r\n// Draws a composition connector between two classes\r\nfunction drawCompositionOrAggregationRelationship(lineGroup, connectionPoint1, connectionPoint2) {\r\n    let connectorOrientation = getConnectorHeadOrientationFromPosition(connectionPoint2.position);\r\n    let lineConnectionPoint = getDiamondLineConnectionPoint(connectionPoint2, connectorOrientation);\r\n    drawConnectorLine(lineGroup, connectionPoint1, lineConnectionPoint, connectorOrientation);\r\n    drawDiamond(lineGroup, connectionPoint2, connectorOrientation);\r\n}\r\nfunction drawSynchronousMessage(lineGroup, textGroup, connectionPoint1, connectionPoint2, label) {\r\n    if ((connectionPoint1.element != null) && (connectionPoint1.element == connectionPoint2.element)) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = SVGUtils_1.SVGUtils.Text(textGroup, 0, 0, label.text);\r\n            textElement.move(connectionPoint1.x + 8, connectionPoint1.y - textElement.bbox().height - 3);\r\n        }\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint1.y);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x + 30, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint2.y);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x + 30, connectionPoint2.y, connectionPoint2.x + 12, connectionPoint2.y);\r\n        let polygonDescription = \"\" + connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6);\r\n        SVGUtils_1.SVGUtils.Polygon(lineGroup, polygonDescription);\r\n    }\r\n    else if (connectionPoint1.x < connectionPoint2.x) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = SVGUtils_1.SVGUtils.Text(textGroup, 0, 0, label.text);\r\n            let width = (connectionPoint2.x - connectionPoint1.x);\r\n            if (textElement.bbox().width < width) {\r\n                textElement.move((connectionPoint1.x + ((width - textElement.bbox().width) / 2)), connectionPoint1.y - textElement.bbox().height - 2);\r\n            }\r\n            else {\r\n                textElement.move(connectionPoint1.x + 2, connectionPoint1.y - 6 - textElement.bbox().height - 2);\r\n            }\r\n        }\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x - 12, connectionPoint2.y);\r\n        let polygonDescription = \"\" + (connectionPoint2.x - 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x - 12) + \",\" + (connectionPoint2.y + 6);\r\n        SVGUtils_1.SVGUtils.Polygon(lineGroup, polygonDescription);\r\n    }\r\n    else if (connectionPoint1.x > connectionPoint2.x) {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = SVGUtils_1.SVGUtils.Text(textGroup, 0, 0, label.text);\r\n            let width = (connectionPoint1.x - connectionPoint2.x);\r\n            if (textElement.bbox().width < width) {\r\n                textElement.move((connectionPoint2.x + ((width - textElement.bbox().width) / 2)), connectionPoint2.y - textElement.bbox().height - 2);\r\n            }\r\n            else {\r\n                textElement.move(connectionPoint2.x + 2, connectionPoint2.y - 6 - textElement.bbox().height - 2);\r\n            }\r\n        }\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x + 12, connectionPoint2.y);\r\n        let polygonDescription = \"\" + (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6);\r\n        SVGUtils_1.SVGUtils.Polygon(lineGroup, polygonDescription);\r\n    }\r\n    else {\r\n        if ((textGroup != null) && (label != null) && (label.text != null) && (label.text != \"\")) {\r\n            let textElement = SVGUtils_1.SVGUtils.Text(textGroup, 0, 0, label.text);\r\n            textElement.move(connectionPoint1.x + 8, connectionPoint1.y - textElement.bbox().height - 3);\r\n        }\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 30, connectionPoint1.y);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x + 30, connectionPoint1.y, connectionPoint2.x + 30, connectionPoint2.y);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x + 30, connectionPoint2.y, connectionPoint2.x + 12, connectionPoint2.y);\r\n        let polygonDescription = \"\" + connectionPoint2.x + \",\" + connectionPoint2.y + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y - 6) + \" \" +\r\n            (connectionPoint2.x + 12) + \",\" + (connectionPoint2.y + 6);\r\n        SVGUtils_1.SVGUtils.Polygon(lineGroup, polygonDescription);\r\n    }\r\n}\r\nfunction drawReturnMessage(lineGroup, connectionPoint1, connectionPoint2) {\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint1.y).attr(\"stroke-dasharray\", \"4, 4\");\r\n    if (connectionPoint2.x >= connectionPoint1.x) {\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x, connectionPoint1.y, connectionPoint2.x - 10, connectionPoint2.y - 6);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x, connectionPoint1.y, connectionPoint2.x - 10, connectionPoint2.y + 6);\r\n    }\r\n    else {\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x, connectionPoint1.y, connectionPoint2.x + 10, connectionPoint2.y - 6);\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x, connectionPoint1.y, connectionPoint2.x + 10, connectionPoint2.y + 6);\r\n    }\r\n}\r\nfunction drawDestructionMessage(lineGroup, connectionPoint2) {\r\n    let halfWidth = 10;\r\n    let halfHeight = 10;\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - halfWidth, connectionPoint2.y - halfHeight, connectionPoint2.x + halfWidth, connectionPoint2.y + halfHeight);\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - halfWidth, connectionPoint2.y + halfHeight, connectionPoint2.x + halfWidth, connectionPoint2.y - halfHeight);\r\n}\r\nfunction drawUseCaseAssociation(lineGroup, connectionPoint1, connectionPoint2) {\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y);\r\n}\r\nfunction drawAssemblyConnector(lineGroup, connectionPoint1, connectionPoint2) {\r\n    if (connectionPoint1.x < connectionPoint2.x) {\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\");\r\n    }\r\n    else {\r\n        let middlePoint = (connectionPoint1.y + ((connectionPoint2.y - connectionPoint1.y) / 2));\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint1.x + 25, connectionPoint1.y).attr(\"stroke-dasharray\", \"8, 4\");\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x + 25, connectionPoint1.y, connectionPoint1.x + 25, middlePoint).attr(\"stroke-dasharray\", \"8, 4\");\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x + 25, middlePoint, connectionPoint2.x - 35, middlePoint).attr(\"stroke-dasharray\", \"8, 4\");\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - 35, middlePoint, connectionPoint2.x - 35, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\");\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - 35, connectionPoint2.y, connectionPoint2.x, connectionPoint2.y).attr(\"stroke-dasharray\", \"8, 4\");\r\n    }\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - 13, connectionPoint2.y + 5, connectionPoint2.x, connectionPoint2.y);\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint2.x - 13, connectionPoint2.y - 5, connectionPoint2.x, connectionPoint2.y);\r\n}\r\nfunction drawCommunicationPath(lineGroup, connectionPoint1, connectionPoint2) {\r\n    SVGUtils_1.SVGUtils.Line(lineGroup, connectionPoint1.x, connectionPoint1.y, connectionPoint2.x, connectionPoint2.y);\r\n}\r\n// Orientation of the head (e.g. arrow or diamond)\r\n// of a connector\r\nvar ConnectorHeadOrientation = {\r\n    Up: 0,\r\n    Down: 1,\r\n    Left: 2,\r\n    Right: 3\r\n};\r\n// Get the orientiation of the head of the connector\r\n// based on where the connector is connected\r\nfunction getConnectorHeadOrientationFromPosition(position) {\r\n    switch (position) {\r\n        case ConnectionPointPosition_1.ConnectionPointPosition.TopCenter:\r\n            return ConnectorHeadOrientation.Down;\r\n        case ConnectionPointPosition_1.ConnectionPointPosition.RightCenter:\r\n            return ConnectorHeadOrientation.Left;\r\n        case ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter:\r\n            return ConnectorHeadOrientation.Up;\r\n        case ConnectionPointPosition_1.ConnectionPointPosition.LeftCenter:\r\n            return ConnectorHeadOrientation.Right;\r\n        default:\r\n            throw new Error(\"Invalid value for ConnectionPointPosition\");\r\n    }\r\n}\r\nfunction getInheritanceArrowLineConnectionPoint(position, orientation) {\r\n    let lineConnectionPoint = { x: 0, y: 0 };\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            lineConnectionPoint = { x: (position.x - 12), y: position.y };\r\n            break;\r\n        case ConnectorHeadOrientation.Left:\r\n            lineConnectionPoint = { x: (position.x + 12), y: position.y };\r\n            break;\r\n        case ConnectorHeadOrientation.Up:\r\n            lineConnectionPoint = { x: position.x, y: (position.y + 12) };\r\n            break;\r\n        case ConnectorHeadOrientation.Down:\r\n            lineConnectionPoint = { x: position.x, y: (position.y - 12) };\r\n            break;\r\n    }\r\n    return lineConnectionPoint;\r\n}\r\n// Draws an arrow for an inheritance relationship. The arrow's tip\r\n// is at the position gives as argument.\r\n// It returns the point to which the line of the connector should\r\n// be connected.\r\nfunction drawInheritanceArrow(svg, position, orientation) {\r\n    let secondPoint = { x: 0, y: 0 };\r\n    let thirdPoint = { x: 0, y: 0 };\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            secondPoint = { x: (position.x - 12), y: (position.y - 10) };\r\n            thirdPoint = { x: (position.x - 12), y: (position.y + 10) };\r\n            break;\r\n        case ConnectorHeadOrientation.Left:\r\n            secondPoint.x = (position.x + 12);\r\n            secondPoint.y = (position.y - 10);\r\n            thirdPoint.x = (position.x + 12);\r\n            thirdPoint.y = (position.y + 10);\r\n            break;\r\n        case ConnectorHeadOrientation.Up:\r\n            secondPoint.x = (position.x - 10);\r\n            secondPoint.y = (position.y + 12);\r\n            thirdPoint.x = (position.x + 10);\r\n            thirdPoint.y = (position.y + 12);\r\n            break;\r\n        case ConnectorHeadOrientation.Down:\r\n            secondPoint.x = (position.x - 10);\r\n            secondPoint.y = (position.y - 12);\r\n            thirdPoint.x = (position.x + 10);\r\n            thirdPoint.y = (position.y - 12);\r\n            break;\r\n    }\r\n    let polygonDescription = \"\" + position.x + \",\" + position.y + \" \" +\r\n        secondPoint.x + \",\" + secondPoint.y + \" \" +\r\n        thirdPoint.x + \",\" + thirdPoint.y;\r\n    SVGUtils_1.SVGUtils.Polygon(svg, polygonDescription);\r\n}\r\nfunction getDiamondLineConnectionPoint(position, orientation) {\r\n    let thirdPoint = { x: 0, y: 0 };\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            thirdPoint = { x: (position.x - 20), y: position.y };\r\n            break;\r\n        case ConnectorHeadOrientation.Left:\r\n            thirdPoint = { x: (position.x + 20), y: position.y };\r\n            break;\r\n        case ConnectorHeadOrientation.Up:\r\n            thirdPoint = { x: position.x, y: (position.y + 20) };\r\n            break;\r\n        case ConnectorHeadOrientation.Down:\r\n            thirdPoint = { x: position.x, y: (position.y - 20) };\r\n            break;\r\n    }\r\n    return thirdPoint;\r\n}\r\n// Draws a diamond for an inheritance relationship. The arrow's tip\r\n// is at the position gives as argument.\r\n// It returns the point to which the line of the connector should\r\n// be connected.\r\nfunction drawDiamond(svg, position, orientation) {\r\n    let secondPoint = { x: 0, y: 0 };\r\n    let thirdPoint = { x: 0, y: 0 };\r\n    let fourthPoint = { x: 0, y: 0 };\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Right:\r\n            secondPoint = { x: (position.x - 10), y: (position.y - 8) };\r\n            thirdPoint = { x: (position.x - 20), y: position.y };\r\n            fourthPoint = { x: (position.x - 10), y: (position.y + 8) };\r\n            break;\r\n        case ConnectorHeadOrientation.Left:\r\n            secondPoint = { x: (position.x + 10), y: (position.y - 8) };\r\n            thirdPoint = { x: (position.x + 20), y: position.y };\r\n            fourthPoint = { x: (position.x + 10), y: (position.y + 8) };\r\n            break;\r\n        case ConnectorHeadOrientation.Up:\r\n            secondPoint = { x: (position.x + 8), y: (position.y + 10) };\r\n            thirdPoint = { x: position.x, y: (position.y + 20) };\r\n            fourthPoint = { x: (position.x - 8), y: (position.y + 10) };\r\n            break;\r\n        case ConnectorHeadOrientation.Down:\r\n            secondPoint = { x: (position.x + 8), y: (position.y - 10) };\r\n            thirdPoint = { x: position.x, y: (position.y - 20) };\r\n            fourthPoint = { x: (position.x - 8), y: (position.y - 10) };\r\n            break;\r\n    }\r\n    let polygonDescription = \"\" + position.x + \",\" + position.y + \" \" +\r\n        secondPoint.x + \",\" + secondPoint.y + \" \" +\r\n        thirdPoint.x + \",\" + thirdPoint.y + \" \" +\r\n        fourthPoint.x + \",\" + fourthPoint.y;\r\n    svg.polygon(polygonDescription);\r\n}\r\nfunction drawConnectorLine(svg, startPoint, endPoint, orientation) {\r\n    switch (orientation) {\r\n        case ConnectorHeadOrientation.Up:\r\n        case ConnectorHeadOrientation.Down:\r\n            let shape1 = getConnectorLineShape1(startPoint, endPoint, orientation);\r\n            switch (shape1) {\r\n                case ConnectorLineShape.Straight:\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, endPoint.x, endPoint.y);\r\n                    break;\r\n                case ConnectorLineShape.TopRightCorner:\r\n                case ConnectorLineShape.TopLeftCorner:\r\n                case ConnectorLineShape.BottomRightCorner:\r\n                case ConnectorLineShape.BottomLeftCorner:\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, endPoint.x, startPoint.y);\r\n                    SVGUtils_1.SVGUtils.Line(svg, endPoint.x, startPoint.y, endPoint.x, endPoint.y);\r\n                    break;\r\n                case ConnectorLineShape.HorizontalStep:\r\n                    let middleY = (endPoint.y + ((startPoint.y - endPoint.y) / 2));\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, startPoint.x, middleY);\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, middleY, endPoint.x, middleY);\r\n                    SVGUtils_1.SVGUtils.Line(svg, endPoint.x, middleY, endPoint.x, endPoint.y);\r\n                    break;\r\n            }\r\n            break;\r\n        case ConnectorHeadOrientation.Left:\r\n        case ConnectorHeadOrientation.Right:\r\n            let shape2 = getConnectorLineShape2(startPoint, endPoint, orientation);\r\n            switch (shape2) {\r\n                case ConnectorLineShape.Straight:\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, endPoint.x, endPoint.y);\r\n                    break;\r\n                case ConnectorLineShape.TopRightCorner:\r\n                case ConnectorLineShape.TopLeftCorner:\r\n                case ConnectorLineShape.BottomRightCorner:\r\n                case ConnectorLineShape.BottomLeftCorner:\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, startPoint.x, endPoint.y);\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, endPoint.y, endPoint.x, endPoint.y);\r\n                    break;\r\n                case ConnectorLineShape.VerticalStep:\r\n                    let middleX = (endPoint.x + ((startPoint.x - endPoint.x) / 2));\r\n                    SVGUtils_1.SVGUtils.Line(svg, startPoint.x, startPoint.y, middleX, startPoint.y);\r\n                    SVGUtils_1.SVGUtils.Line(svg, middleX, startPoint.y, middleX, endPoint.y);\r\n                    SVGUtils_1.SVGUtils.Line(svg, middleX, endPoint.y, endPoint.x, endPoint.y);\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n}\r\n// Orientation of the head (e.g. arrow or diamond)\r\n// of a connector\r\nvar ConnectorLineShape = {\r\n    Straight: 0,\r\n    TopRightCorner: 1,\r\n    TopLeftCorner: 2,\r\n    BottomRightCorner: 3,\r\n    BottomLeftCorner: 4,\r\n    HorizontalStep: 5,\r\n    VerticalStep: 6\r\n};\r\nfunction getConnectorLineShape1(startPoint, endPoint, orientation) {\r\n    let result = ConnectorLineShape.Straight;\r\n    if (endPoint.x == startPoint.x) {\r\n        result = ConnectorLineShape.Straight;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Down) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.RightCenter)) {\r\n        result = ConnectorLineShape.TopRightCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Down) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.LeftCenter)) {\r\n        result = ConnectorLineShape.TopLeftCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Up) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.RightCenter)) {\r\n        result = ConnectorLineShape.BottomRightCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Up) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.LeftCenter)) {\r\n        result = ConnectorLineShape.BottomLeftCorner;\r\n    }\r\n    else {\r\n        result = ConnectorLineShape.HorizontalStep;\r\n    }\r\n    return result;\r\n}\r\nfunction getConnectorLineShape2(startPoint, endPoint, orientation) {\r\n    let result = ConnectorLineShape.Straight;\r\n    if (endPoint.y == startPoint.y) {\r\n        result = ConnectorLineShape.Straight;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Right) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter)) {\r\n        result = ConnectorLineShape.BottomLeftCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Right) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.TopCenter)) {\r\n        result = ConnectorLineShape.TopLeftCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Left) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter)) {\r\n        result = ConnectorLineShape.BottomRightCorner;\r\n    }\r\n    else if ((orientation == ConnectorHeadOrientation.Left) && (startPoint.position == ConnectionPointPosition_1.ConnectionPointPosition.TopCenter)) {\r\n        result = ConnectorLineShape.TopRightCorner;\r\n    }\r\n    else {\r\n        result = ConnectorLineShape.VerticalStep;\r\n    }\r\n    return result;\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Connector.ts?");

/***/ }),

/***/ "./src/Diagram.ts":
/*!************************!*\
  !*** ./src/Diagram.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Settings_1 = __webpack_require__(/*! ./Settings */ \"./src/Settings.ts\");\r\nconst Style_1 = __webpack_require__(/*! ./Style */ \"./src/Style.ts\");\r\nconst LayoutManager_1 = __webpack_require__(/*! ./LayoutManager */ \"./src/LayoutManager.ts\");\r\nconst ClassBox_1 = __webpack_require__(/*! ./ClassBox */ \"./src/ClassBox.ts\");\r\nconst ClassTemplate_1 = __webpack_require__(/*! ./ClassTemplate */ \"./src/ClassTemplate.ts\");\r\nconst Component_1 = __webpack_require__(/*! ./Component */ \"./src/Component.ts\");\r\nconst Lifeline_1 = __webpack_require__(/*! ./Lifeline */ \"./src/Lifeline.ts\");\r\nconst Node_1 = __webpack_require__(/*! ./Node */ \"./src/Node.ts\");\r\nconst Actor_1 = __webpack_require__(/*! ./Actor */ \"./src/Actor.ts\");\r\nconst UseCase_1 = __webpack_require__(/*! ./UseCase */ \"./src/UseCase.ts\");\r\nconst Connector_1 = __webpack_require__(/*! ./Connector */ \"./src/Connector.ts\");\r\nconst Metrics_1 = __webpack_require__(/*! ./Metrics */ \"./src/Metrics.ts\");\r\nconst Log_1 = __webpack_require__(/*! ./Log */ \"./src/Log.ts\");\r\nconst IDGenerator_1 = __webpack_require__(/*! ./IDGenerator */ \"./src/IDGenerator.ts\");\r\nconst Errors_1 = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\r\n/**\r\n * This class is the entry point for all the functionality provided by the CodeSmithy UMLWebWidget.\r\n */\r\nclass Diagram {\r\n    constructor(settings) {\r\n        this.settings = new Settings_1.Settings(settings);\r\n        this.errors = new Errors_1.Errors(this.settings.buildType);\r\n        this.log = new Log_1.Log(this.settings.logLevel);\r\n        this.metrics = new Metrics_1.Metrics();\r\n        // The description of the UML diagram in JSON\r\n        // format. This will then be parsed to create\r\n        // the graphical form.\r\n        this.diagramDescription = {};\r\n        // The list of all UML class boxes present on the\r\n        // diagram\r\n        this.classboxes = new Map();\r\n        // The list of all UML class templates present on the\r\n        // diagram\r\n        this.classtemplates = new Map();\r\n        // The list of all UML lifelines present on the\r\n        // diagram\r\n        this.lifelines = new Map();\r\n        // The list of all UML components present on the\r\n        // diagram\r\n        this.components = new Map();\r\n        this.nodes = new Map();\r\n        // The list of all UML actors present on the\r\n        // diagram\r\n        this.actors = new Map();\r\n        // The list of all UML use cases present on the\r\n        // diagram\r\n        this.usecases = new Map();\r\n        this.messages = [];\r\n    }\r\n    // Create a diagram from a div element in the HTML document.\r\n    // The div element must contain a JSON object with the UML\r\n    // diagram information. The contents of the div will be replaced\r\n    // by the diagram.\r\n    // - divId: this is the id of the div element to use, it should be the id\r\n    //   without any '#' prefix.\r\n    createFromDiv(divId, layout) {\r\n        let jsonDiagramDescription = JSON.parse($('#' + divId).text());\r\n        $('#' + divId).empty();\r\n        var svg = SVG(divId).size(this.settings.width, this.settings.height);\r\n        this.createFromJSON(svg, divId, jsonDiagramDescription, layout);\r\n    }\r\n    createFromJSON(svg, id, jsonDiagramDescription, layout) {\r\n        let idGenerator = new IDGenerator_1.IDGenerator(id);\r\n        if (jsonDiagramDescription == null) {\r\n            jsonDiagramDescription = {};\r\n        }\r\n        this.diagramDescription = jsonDiagramDescription;\r\n        let style = new Style_1.Style();\r\n        if (this.diagramDescription.elements) {\r\n            this.drawDiagram(svg, idGenerator, this.diagramDescription.elements, style, layout, this.errors);\r\n        }\r\n    }\r\n    drawDiagram(svg, idGenerator, description, style, layout, errors) {\r\n        let layoutManager = new LayoutManager_1.LayoutManager(layout);\r\n        let connectors = [];\r\n        let assemblyconnectors = [];\r\n        // Construct the elements\r\n        for (var i = 0; i < description.length; i++) {\r\n            let item = description[i];\r\n            if (item.class) {\r\n                this.classboxes.set(item.class.name, new ClassBox_1.ClassBox(svg, idGenerator, item.class, this.settings.canMove, style, errors));\r\n            }\r\n            else if (item.classtemplate) {\r\n                this.classtemplates.set(item.classtemplate.name, new ClassTemplate_1.ClassTemplate(svg, idGenerator, item.classtemplate, style, errors));\r\n            }\r\n            else if (item.lifeline) {\r\n                this.lifelines.set(item.lifeline.name, new Lifeline_1.Lifeline(svg, idGenerator, item.lifeline, style, this.log, errors));\r\n            }\r\n            else if (item.component) {\r\n                this.components.set(item.component.name, new Component_1.Component(svg, item.component.name, item.component, style, errors));\r\n            }\r\n            else if (item.node) {\r\n                this.nodes.set(item.node.name, new Node_1.Node(svg, idGenerator, item.node, style, errors));\r\n            }\r\n            else if (item.actor) {\r\n                this.actors.set(item.actor.name, new Actor_1.Actor(svg, item.actor.name, item.actor, errors));\r\n            }\r\n            else if (item.usecase) {\r\n                this.usecases.set(item.usecase.title, new UseCase_1.UseCase(svg, item.usecase.title, item.usecase, errors));\r\n            }\r\n            else if (item.relationship) {\r\n                let classbox1;\r\n                let classbox2;\r\n                let connectorType = item.relationship.type;\r\n                if (item.relationship.type == \"inheritance\") {\r\n                    connectorType = \"inheritance\" /* InheritanceConnector */;\r\n                    classbox1 = this.classboxes.get(item.relationship.derivedclass);\r\n                    if (classbox1 == null) {\r\n                        classbox1 = this.classtemplates.get(item.relationship.derivedclass);\r\n                    }\r\n                    classbox2 = this.classboxes.get(item.relationship.baseclass);\r\n                    if (classbox2 == null) {\r\n                        classbox2 = this.classtemplates.get(item.relationship.baseclass);\r\n                    }\r\n                }\r\n                else if ((item.relationship.type == \"composition\") || (item.relationship.type == \"aggregation\")) {\r\n                    connectorType = item.relationship.type;\r\n                    classbox1 = this.classboxes.get(item.relationship.containedclass);\r\n                    classbox2 = this.classboxes.get(item.relationship.containingclass);\r\n                }\r\n                let connectionPoint1 = classbox1.createConnectionPoint(svg);\r\n                let connectionPoint2 = classbox2.createConnectionPoint(svg);\r\n                let newConnector = new Connector_1.Connector(svg, connectorType, connectionPoint1, connectionPoint2, null);\r\n                connectors.push(newConnector);\r\n            }\r\n            else if (item.messages) {\r\n                for (let j = 0; j < item.messages.length; j++) {\r\n                    let message = item.messages[j];\r\n                    let newConnector;\r\n                    if (message.synchronousmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.synchronousmessage.caller);\r\n                        let lifeline2 = this.lifelines.get(message.synchronousmessage.callee);\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"synchronous-start\");\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"synchronous-end\");\r\n                        newConnector = new Connector_1.Connector(svg, \"synchronousmessage\" /* SynchronousMessageConnector */, connectionPoint1, connectionPoint2, message.synchronousmessage.name);\r\n                    }\r\n                    else if (message.returnmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.returnmessage.callee);\r\n                        let lifeline2 = this.lifelines.get(message.returnmessage.caller);\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"return-start\");\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"return-end\");\r\n                        newConnector = new Connector_1.Connector(svg, \"returnmessage\" /* ReturnMessageConnector */, connectionPoint1, connectionPoint2, null);\r\n                    }\r\n                    else if (message.creationmessage) {\r\n                        let lifeline1 = this.lifelines.get(message.creationmessage.caller);\r\n                        let lifeline2 = this.lifelines.get(message.creationmessage.callee);\r\n                        let connectionPoint1 = lifeline1.createConnectionPoint(svg, \"creation-start\");\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"creation-end\");\r\n                        newConnector = new Connector_1.Connector(svg, \"creationmessage\" /* CreationMessageConnector */, connectionPoint1, connectionPoint2, null);\r\n                    }\r\n                    else if (message.destructionmessage) {\r\n                        let lifeline2 = this.lifelines.get(message.destructionmessage.callee);\r\n                        let connectionPoint2 = lifeline2.createConnectionPoint(svg, \"destruction-end\");\r\n                        newConnector = new Connector_1.Connector(svg, \"destructionmessage\" /* DestructionMessageConnector */, connectionPoint2, connectionPoint2, \"\");\r\n                    }\r\n                    this.messages.push(newConnector);\r\n                }\r\n            }\r\n            else if (item.assemblyconnector) {\r\n                let consumerComponent = this.components.get(item.assemblyconnector.consumer);\r\n                let providerComponent = this.components.get(item.assemblyconnector.provider);\r\n                let connectionPoint1 = consumerComponent.createDependencyConnectionPoint(svg, item.assemblyconnector.interface);\r\n                let connectionPoint2 = providerComponent.createInterfaceConnectionPoint(svg, item.assemblyconnector.interface);\r\n                let newConnector = new Connector_1.Connector(svg, \"assemblyconnector\", connectionPoint1, connectionPoint2, null);\r\n                assemblyconnectors.push(newConnector);\r\n            }\r\n            else if (item.association) {\r\n                let connectionPoint1 = this.actors.get(item.association.actor).createConnectionPoint(svg);\r\n                let connectionPoint2 = this.usecases.get(item.association.usecase).createConnectionPoint(svg);\r\n                let newConnector = new Connector_1.Connector(svg, \"usecaseassociation\", connectionPoint1, connectionPoint2, null);\r\n                connectors.push(newConnector);\r\n            }\r\n            else if (item.communicationpath) {\r\n                let connectionPoint1 = this.nodes.get(item.communicationpath.firstnode).createConnectionPoint(svg);\r\n                let connectionPoint2 = this.nodes.get(item.communicationpath.secondnode).createConnectionPoint(svg);\r\n                let newConnector = new Connector_1.Connector(svg, \"communicationpath\", connectionPoint1, connectionPoint2, null);\r\n                connectors.push(newConnector);\r\n            }\r\n        }\r\n        layoutManager.doLayout(this);\r\n        dolayout(layoutManager, connectors, assemblyconnectors);\r\n        draw(this.classboxes.values(), this.classtemplates.values(), this.lifelines.values(), this.components.values(), this.nodes.values(), this.actors.values(), this.usecases.values(), connectors, this.messages, assemblyconnectors);\r\n    }\r\n}\r\nexports.Diagram = Diagram;\r\nfunction dolayout(layoutManager, connectors, assemblyconnectors) {\r\n    if (connectors != null) {\r\n        layoutManager.layoutConnectors(connectors);\r\n    }\r\n    if (assemblyconnectors != null) {\r\n        for (var i = 0; i < assemblyconnectors.length; i++) {\r\n            let connector = assemblyconnectors[i];\r\n            connector.connectionPoint1.move(connector.connectionPoint1.element.component.getSocketConnectionPoint(\"\").x, connector.connectionPoint1.element.component.getSocketConnectionPoint(\"\").y);\r\n            connector.connectionPoint2.move(connector.connectionPoint2.element.component.getBallConnectionPoint(\"\").x, connector.connectionPoint2.element.component.getBallConnectionPoint(\"\").y);\r\n        }\r\n    }\r\n}\r\nfunction draw(classboxes, classtemplates, lifelines, components, nodes, actors, usecases, connectors, messages, assemblyconnectors) {\r\n    for (let classbox of classboxes) {\r\n        classbox.draw();\r\n    }\r\n    for (let classtemplate of classtemplates) {\r\n        classtemplate.draw();\r\n    }\r\n    for (let lifeline of lifelines) {\r\n        lifeline.draw();\r\n    }\r\n    for (let component of components) {\r\n        component.draw();\r\n    }\r\n    for (let node of nodes) {\r\n        node.draw();\r\n    }\r\n    for (let actor of actors) {\r\n        actor.draw();\r\n    }\r\n    for (let usecase of usecases) {\r\n        usecase.draw();\r\n    }\r\n    for (let connector of connectors) {\r\n        connector.draw();\r\n    }\r\n    for (let connector of messages) {\r\n        connector.draw();\r\n    }\r\n    for (let connector of assemblyconnectors) {\r\n        connector.getLayers().getLayer(\"shape\").write();\r\n        connector.getLayers().getLayer(\"text\").write();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Diagram.ts?");

/***/ }),

/***/ "./src/DiagramElement.ts":
/*!*******************************!*\
  !*** ./src/DiagramElement.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGLayerSet_1 = __webpack_require__(/*! ./SVGLayerSet */ \"./src/SVGLayerSet.ts\");\r\nvar position = Symbol();\r\n/**\r\n * An element of a diagram.\r\n *\r\n * @property {SVGLayerSet} this.layers - The various SVG layers to use to render this element.\r\n * @property {boolean} this.uptodate - Whether the layers need to be updated because of changes to the element.\r\n */\r\nclass DiagramElement {\r\n    /**\r\n     * Creates a new DiagramElement instance.\r\n     *\r\n     * @param {SVG} svg - The root SVG document.\r\n     * @param {string} id - A unique identifier for this element.\r\n     */\r\n    constructor(svg, type, id) {\r\n        this.type = type;\r\n        this.id = id;\r\n        this.layers = new SVGLayerSet_1.SVGLayerSet(svg);\r\n        this.uptodate = false;\r\n        this[position] = { x: 0, y: 0 };\r\n    }\r\n    /**\r\n     * Gets the layers of the element. This checks if any changes were made to the element and calls\r\n     * {@link DiagramElement#update} if necessary before returning the layers.\r\n     *\r\n     * @returns {SVGLayerSet} The SVG layers to use to draw the element.\r\n     */\r\n    getLayers() {\r\n        this.update();\r\n        return this.layers;\r\n    }\r\n    get x() {\r\n        return this[position].x;\r\n    }\r\n    get y() {\r\n        return this[position].y;\r\n    }\r\n    move(x, y) {\r\n        this.uptodate = false;\r\n        this[position].x = x;\r\n        this[position].y = y;\r\n    }\r\n    /**\r\n     * Returns the rectangle on which connection point can be placed. Returns null if no connection points are allowed\r\n     * or where they can be placed can't be expressed as a rectangle.\r\n     */\r\n    getConnectionPointsRectangle() {\r\n        this.update();\r\n        return this.doGetConnectionPointsRectangle();\r\n    }\r\n    update() {\r\n        if (!this.uptodate) {\r\n            this.doUpdate();\r\n            this.uptodate = true;\r\n        }\r\n    }\r\n    /**\r\n     * This function must be called after changes were made to update the contents of the SVG layers.\r\n     *\r\n     * @virtual\r\n     */\r\n    doUpdate() {\r\n    }\r\n    /**\r\n     * Implements the getConnectionPointsRectangle method.\r\n     *\r\n     * @virtual\r\n     */\r\n    doGetConnectionPointsRectangle() {\r\n        return null;\r\n    }\r\n}\r\nexports.DiagramElement = DiagramElement;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/DiagramElement.ts?");

/***/ }),

/***/ "./src/DrawingUtilities.ts":
/*!*********************************!*\
  !*** ./src/DrawingUtilities.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass DrawingUtilities {\r\n    // Add an attribute or operation compartment and updates the current dimensions\r\n    // of the class box\r\n    static addClassCompartmentText(x, y, textLayer, style, items, cssClass) {\r\n        y += style.getTopMargin(\"classbox\");\r\n        let dimensions = createAttributeOrOperationGroupDef(x + style.getLeftMargin(\"classbox\"), y, textLayer, items, cssClass);\r\n        dimensions.height += (style.getTopMargin(\"classbox\") + style.getBottomMargin(\"classbox\"));\r\n        return dimensions;\r\n    }\r\n}\r\nexports.DrawingUtilities = DrawingUtilities;\r\n// Creates a group with all the attributes or operations\r\nfunction createAttributeOrOperationGroupDef(x, y, textLayer, items, cssClass) {\r\n    let width = 0;\r\n    let height = 0;\r\n    let itemGroupDef = textLayer.group().addClass(cssClass);\r\n    for (var i = 0; i < items.length; i++) {\r\n        let itemDef = createAttributeOrOperationDef(itemGroupDef, items[i]);\r\n        itemDef.move(x, y + height);\r\n        width = Math.max(width, itemDef.bbox().width);\r\n        height += itemDef.bbox().height;\r\n    }\r\n    return { width: width, height: height };\r\n}\r\n// Creates a single attribute or operation line\r\nfunction createAttributeOrOperationDef(svg, item) {\r\n    let text = visibilityStringToSymbol(item.visibility) + item.name;\r\n    if (item.return) {\r\n        text += \" : \" + item.return;\r\n    }\r\n    return svg.text(text);\r\n}\r\n// Converts the visibility from the user string provided\r\n// in the input to the appropriate UML symbol for\r\n// visibility\r\nfunction visibilityStringToSymbol(visibility) {\r\n    let stringToSymbolMap = {\r\n        \"public\": \"+ \",\r\n        \"protected\": \"# \",\r\n        \"private\": \"- \"\r\n    };\r\n    return stringToSymbolMap[visibility];\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/DrawingUtilities.ts?");

/***/ }),

/***/ "./src/Errors.ts":
/*!***********************!*\
  !*** ./src/Errors.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Class that provides methods to handle errors.\r\n */\r\nclass Errors {\r\n    constructor(buildType) {\r\n        this.buildType = buildType;\r\n    }\r\n    assertAlways(condition) {\r\n        if (!condition) {\r\n            console.error(\"Assertion failed\");\r\n            window.alert(\"Assertion failed\");\r\n            throw new Error();\r\n        }\r\n    }\r\n    assertDebug(condition) {\r\n        if (this.buildType == 0 /* DEBUG */) {\r\n            this.assertAlways(condition);\r\n        }\r\n    }\r\n}\r\nexports.Errors = Errors;\r\n/**\r\n * Errors related to diagram operations are communicated via this class.\r\n *\r\n * Note that by default errors are only shown if debug mode is enabled in the {@link Settings}.\r\n */\r\nclass UMLWebWidgetError extends Error {\r\n}\r\nexports.UMLWebWidgetError = UMLWebWidgetError;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Errors.ts?");

/***/ }),

/***/ "./src/IDGenerator.ts":
/*!****************************!*\
  !*** ./src/IDGenerator.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass IDGenerator {\r\n    constructor(prefix) {\r\n        this.prefix = prefix;\r\n    }\r\n    createID(type) {\r\n        return (this.prefix + \"--\" + type);\r\n    }\r\n}\r\nexports.IDGenerator = IDGenerator;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/IDGenerator.ts?");

/***/ }),

/***/ "./src/Label.ts":
/*!**********************!*\
  !*** ./src/Label.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Label {\r\n    constructor(text) {\r\n        this.text = text;\r\n    }\r\n    empty() {\r\n        return ((this.text == null) || (this.text == \"\"));\r\n    }\r\n}\r\nexports.Label = Label;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Label.ts?");

/***/ }),

/***/ "./src/LayoutManager.ts":
/*!******************************!*\
  !*** ./src/LayoutManager.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ConnectionPointPosition_ts_1 = __webpack_require__(/*! ./ConnectionPointPosition.ts */ \"./src/ConnectionPointPosition.ts\");\r\n/** Sets the position of the elements on the diagram. */\r\nclass LayoutManager {\r\n    constructor(layout) {\r\n        this.layout = layout;\r\n        if (this.layout == null) {\r\n            this.layout = {};\r\n        }\r\n        if (this.layout.elements == null) {\r\n            this.layout.elements = {};\r\n        }\r\n        if (this.layout.connectorpositions == null) {\r\n            this.layout.connectorpositions = {};\r\n        }\r\n    }\r\n    doLayout(diagram) {\r\n        for (let classbox of diagram.classboxes.values()) {\r\n            this.setElementPosition(classbox);\r\n        }\r\n        for (let lifeline of diagram.lifelines.values()) {\r\n            this.setElementPosition(lifeline);\r\n        }\r\n        for (let component of diagram.components.values()) {\r\n            this.setElementPosition(component);\r\n        }\r\n        for (let node of diagram.nodes.values()) {\r\n            this.setElementPosition(node);\r\n        }\r\n        for (let actor of diagram.actors.values()) {\r\n            this.setElementPosition(actor);\r\n        }\r\n        for (let usecase of diagram.usecases.values()) {\r\n            this.setElementPosition(usecase);\r\n        }\r\n        this.layoutMessages(diagram.lifelines, diagram.messages);\r\n    }\r\n    setElementPosition(element) {\r\n        let elementLayout = this.layout.elements[element.id];\r\n        if (elementLayout) {\r\n            if (elementLayout.position) {\r\n                element.move(elementLayout.position.x, elementLayout.position.y);\r\n            }\r\n        }\r\n    }\r\n    layoutConnectors(connectors) {\r\n        for (var i = 0; i < connectors.length; i++) {\r\n            let connector = connectors[i];\r\n            let connectionPoint1 = connector.connectionPoint1;\r\n            let connectionPoint2 = connector.connectionPoint2;\r\n            let bbox1 = connectionPoint1.element.getConnectionPointsRectangle();\r\n            let bbox2 = connectionPoint2.element.getConnectionPointsRectangle();\r\n            let connectionPositions = this.getConnectionPositions(bbox1, bbox2, connector.type);\r\n            let connectorId = connectionPoint1.element.id + \"-\" + connectionPoint2.element.id + \"-\" + connector.type;\r\n            let layoutOverride = this.layout.elements[connectorId];\r\n            if (layoutOverride) {\r\n                if (layoutOverride.end) {\r\n                    switch (layoutOverride.end) {\r\n                        case \"top-center\":\r\n                            connectionPositions.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter;\r\n                            break;\r\n                        case \"right-center\":\r\n                            connectionPositions.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.RightCenter;\r\n                            break;\r\n                        case \"bottom-center\":\r\n                            connectionPositions.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.BottomCenter;\r\n                            break;\r\n                        case \"left-center\":\r\n                            connectionPositions.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.LeftCenter;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            connectionPoint1.setPosition(connectionPositions.start);\r\n            connectionPoint2.setPosition(connectionPositions.end);\r\n        }\r\n    }\r\n    layoutMessages(lifelines, connectors) {\r\n        let currrentYPosition = 0;\r\n        for (let lifeline of lifelines.values()) {\r\n            currrentYPosition = Math.max(currrentYPosition, lifeline.getFirstConnectionPointPosition().y);\r\n        }\r\n        let firstConnector = true;\r\n        for (let connector of connectors) {\r\n            if (firstConnector) {\r\n                firstConnector = false;\r\n                if (connector.hasNonEmptyLabel() && (connector.type != \"creationmessage\")) {\r\n                    currrentYPosition += 10;\r\n                }\r\n            }\r\n            else {\r\n                if (connector.hasNonEmptyLabel()) {\r\n                    currrentYPosition += 16;\r\n                }\r\n            }\r\n            let connectionPoint1 = connector.connectionPoint1;\r\n            let connectionPoint2 = connector.connectionPoint2;\r\n            let lifeline1 = connectionPoint1.element;\r\n            let lifeline2 = connectionPoint2.element;\r\n            if ((connector.type != \"creationmessage\") && (connector.type != \"destructionmessage\")) {\r\n                if (lifeline1 != lifeline2) {\r\n                    connectionPoint1.move(lifeline1.getLineTopPosition().x, currrentYPosition);\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition);\r\n                    currrentYPosition += 14;\r\n                }\r\n                else {\r\n                    connectionPoint1.move(lifeline1.getLineTopPosition().x, currrentYPosition);\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition + 20);\r\n                    if (connector.type != \"returnmessage\") {\r\n                        currrentYPosition += 34;\r\n                    }\r\n                }\r\n            }\r\n            else if (connector.type == \"creationmessage\") {\r\n                lifeline2.move(lifeline2.x, currrentYPosition);\r\n                let y = lifeline2.getCreationConnectionPointPosition().y;\r\n                connectionPoint1.move(lifeline1.getLineTopPosition().x, y);\r\n                connectionPoint2.move(lifeline2.getCreationConnectionPointPosition().x, y);\r\n                currrentYPosition += 34;\r\n            }\r\n            else if (connector.type == \"destructionmessage\") {\r\n                if (lifeline2.needToAdjustDestructionPosition()) {\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition + 25);\r\n                }\r\n                else {\r\n                    connectionPoint2.move(lifeline2.getLineTopPosition().x, currrentYPosition);\r\n                }\r\n                currrentYPosition += 14;\r\n            }\r\n        }\r\n        if (connectors.length > 0) {\r\n            for (let lifeline of lifelines.values()) {\r\n                lifeline.doLayout();\r\n                lifeline.uptodate = false;\r\n            }\r\n        }\r\n        // Do a second pass to adjust the x position based on the width of the \r\n        // line which varies because of execution specifications\r\n        for (let connector of connectors) {\r\n            let connectionPoint1 = connector.connectionPoint1;\r\n            let connectionPoint2 = connector.connectionPoint2;\r\n            let lifeline1 = connectionPoint1.element;\r\n            let lifeline2 = connectionPoint2.element;\r\n            if (lifeline1 == lifeline2) {\r\n                let y1 = connectionPoint1.y;\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"right\");\r\n                connectionPoint1.move(x1, y1);\r\n                let y2 = connectionPoint2.y;\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"right\");\r\n                connectionPoint2.move(x2, y2);\r\n            }\r\n            else if (lifeline2.x >= lifeline1.x) {\r\n                let y1 = connectionPoint1.y;\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"right\");\r\n                connectionPoint1.move(x1, y1);\r\n                let y2 = connectionPoint2.y;\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"left\");\r\n                connectionPoint2.move(x2, y2);\r\n            }\r\n            else {\r\n                let y1 = connectionPoint1.y;\r\n                let x1 = connectionPoint1.x + lifeline1.getHorizontalOffset(y1, \"left\");\r\n                connectionPoint1.move(x1, y1);\r\n                let y2 = connectionPoint2.y;\r\n                let x2 = connectionPoint2.x + lifeline2.getHorizontalOffset(y2, \"right\");\r\n                connectionPoint2.move(x2, y2);\r\n            }\r\n            connector.uptodate = false;\r\n        }\r\n    }\r\n    getConnectionPositions(boundingbox1, boundingbox2, type) {\r\n        let result = {\r\n            start: ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter,\r\n            end: ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter\r\n        };\r\n        if (type != \"usecaseassociation\") {\r\n            if ((boundingbox2.y + boundingbox2.height) < boundingbox1.y) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.BottomCenter;\r\n            }\r\n            else if ((boundingbox1.y + boundingbox1.height) < boundingbox2.y) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.BottomCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter;\r\n            }\r\n            else if ((boundingbox2.x + boundingbox2.width) < boundingbox1.x) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.LeftCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.RightCenter;\r\n            }\r\n            else if ((boundingbox1.x + boundingbox1.width) < boundingbox2.x) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.RightCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.LeftCenter;\r\n            }\r\n        }\r\n        else {\r\n            if (boundingbox1.x < boundingbox2.x) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.RightCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.LeftCenter;\r\n            }\r\n            else if (boundingbox1.x > (boundingbox2.x + boundingbox2.width)) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.LeftCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.RightCenter;\r\n            }\r\n            else if (boundingbox1.y < boundingbox2.y) {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.BottomCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter;\r\n            }\r\n            else {\r\n                result.start = ConnectionPointPosition_ts_1.ConnectionPointPosition.TopCenter;\r\n                result.end = ConnectionPointPosition_ts_1.ConnectionPointPosition.BottomCenter;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LayoutManager = LayoutManager;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/LayoutManager.ts?");

/***/ }),

/***/ "./src/Lifeline.ts":
/*!*************************!*\
  !*** ./src/Lifeline.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nconst LifelineLayout_1 = __webpack_require__(/*! ./LifelineLayout */ \"./src/LifelineLayout.ts\");\r\nconst SVGUtils_1 = __webpack_require__(/*! ./SVGUtils */ \"./src/SVGUtils.ts\");\r\nconst SVGLayer_1 = __webpack_require__(/*! ./SVGLayer */ \"./src/SVGLayer.ts\");\r\n/**\r\n * A lifeline on a sequence diagram.\r\n *\r\n * @extends DiagramElement\r\n */\r\nclass Lifeline extends DiagramElement_1.DiagramElement {\r\n    /**\r\n     * <p>\r\n     *   Creates a new Lifeline instance.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     *   At construction time the messages related to this lifeline are not known. They will be added later by calls to\r\n     *   {@link Lifeline#createConnectionPoint}. Layout has to be performed after all messages have been added.\r\n     * </p>\r\n     *\r\n     * @param {SVG} svg - The root SVG document.\r\n     */\r\n    constructor(svg, idGenerator, lifelineDescription, style, log, errors) {\r\n        super(svg, \"lifeline\" /* Lifeline */, idGenerator.createID(\"lifeline--\" + lifelineDescription.name));\r\n        this.errors = errors;\r\n        this.headShapeLayer = this.layers.createLayer(\"head-shape\");\r\n        this.headTextLayer = this.layers.createLayer(\"head-text\");\r\n        this.lineLayer = this.layers.createLayer(\"line\");\r\n        this.svg = svg;\r\n        this.lifelineDescription = lifelineDescription;\r\n        this.style = style;\r\n        this.log = log;\r\n        this.lineTopPosition = { x: 0, y: 0 };\r\n        this.boxHeight = 0;\r\n        // List of connection points that are connected to this lifeline\r\n        this.connectionPoints = [];\r\n        this.adjustmentNeeded = false;\r\n        this.lifelineLayout = new LifelineLayout_1.LifelineLayout();\r\n    }\r\n    draw() {\r\n        this.update();\r\n        let g = this.layers.svg.group().addClass(\"lifeline\" /* Lifeline */);\r\n        g.id(this.id);\r\n        let headGroup = SVGUtils_1.SVGUtils.Group(g).addClass(\"lifeline__lifeline-head\" /* Lifeline_Head */);\r\n        this.layers.getLayer(\"head-shape\").write(headGroup);\r\n        this.layers.getLayer(\"head-text\").write(headGroup);\r\n        this.layers.getLayer(\"line\").write(g);\r\n    }\r\n    /**\r\n     * <p>\r\n     *   Creates a new connection point. Connection points are used to link lifelines and messages.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     *   Calls to this functions are also used to communicate to the lifeline which messages it receives or sends. The\r\n     *   order of the calls therefore matters as the order of the messages is assumed to be the order in which this\r\n     *   function is called.\r\n     * </p>\r\n     *\r\n     * @param {SVG} svg - The root SVG document.\r\n     * @param {string} type - The type of the message.\r\n     * @returns {ConnectionPoint}\r\n     */\r\n    createConnectionPoint(svg, type) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        this.connectionPoints.push({ point: newPoint, type: type });\r\n        return newPoint;\r\n    }\r\n    getLineTopPosition() {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        return this.lineTopPosition;\r\n    }\r\n    getFirstConnectionPointPosition() {\r\n        let position = this.getLineTopPosition();\r\n        position.y += (this.style.getExecutionSpecificationBarMargin() + this.style.getExecutionSpecificationBarOverhang());\r\n        return position;\r\n    }\r\n    getCreationConnectionPointPosition() {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        return { x: this.x, y: (this.y + (this.boxHeight / 2)) };\r\n    }\r\n    getActiveLineWidth() {\r\n        return this.style.getExecutionSpecificationBarWidth();\r\n    }\r\n    getHorizontalOffset(y, side) {\r\n        let result = 0;\r\n        if (side == \"right\") {\r\n            result = (this.lifelineLayout.getDepth(y) * (this.getActiveLineWidth() / 2));\r\n        }\r\n        else if (side == \"left\") {\r\n            result = -(this.lifelineLayout.getDepth(y) * (this.getActiveLineWidth() / 2));\r\n        }\r\n        return result;\r\n    }\r\n    needToAdjustDestructionPosition() {\r\n        if (this.connectionPoints.length > 1) {\r\n            if ((this.connectionPoints[this.connectionPoints.length - 1].type != \"return-start\") &&\r\n                (this.connectionPoints[this.connectionPoints.length - 1].type != \"creation-end\")) {\r\n                this.adjustmentNeeded = true;\r\n            }\r\n        }\r\n        return this.adjustmentNeeded;\r\n    }\r\n    doLayout() {\r\n        this.lifelineLayout.dolayout(this.connectionPoints, this.adjustmentNeeded);\r\n    }\r\n    doUpdate() {\r\n        this.log.info(\"Lifeline \" + this.id + \": updating\");\r\n        this.layers.clearEachLayer();\r\n        let headGroup = this.headShapeLayer.group().addClass(\"lifeline-head__shape\" /* Lifeline_Head_Shape */);\r\n        let lineGroup = this.lineLayer.group().addClass(\"lifeline__lifeline-line\" /* Lifeline_Line */);\r\n        // The box need to be updated first because the position of the top of the line is computed as part of that\r\n        // update\r\n        updateBox(this, headGroup, this.lifelineDescription, this.style, this.lineTopPosition);\r\n        updateLine(this, lineGroup, this.lifelineDescription, this.lifelineLayout.depthChanges, this.style);\r\n    }\r\n}\r\nexports.Lifeline = Lifeline;\r\n// Create the box at the top of the lifeline\r\nfunction updateBox(self, headGroup, lifelineDescription, style, lineTopPosition) {\r\n    let currentDimensions = {\r\n        width: 0,\r\n        height: 0\r\n    };\r\n    let borderAdjustment = {\r\n        top: self.y + 1,\r\n        left: self.x + 1\r\n    };\r\n    currentDimensions.height = style.getTopMargin(\"lifeline\");\r\n    var instanceNameGroup = self.headTextLayer.group().addClass(\"lifeline-head__text\" /* Lifeline_Head_Text */);\r\n    var instanceNameDef = SVGUtils_1.SVGUtils.Text(instanceNameGroup, borderAdjustment.left + style.getLeftMargin(\"lifeline\"), borderAdjustment.top + currentDimensions.height, \":\" + lifelineDescription.name);\r\n    currentDimensions.width = Math.max(currentDimensions.width, instanceNameDef.bbox().width);\r\n    currentDimensions.height += (instanceNameDef.bbox().height + style.getBottomMargin(\"lifeline\"));\r\n    currentDimensions.width += (style.getLeftMargin(\"lifeline\") + style.getRightMargin(\"lifeline\"));\r\n    SVGUtils_1.SVGUtils.Rectangle(headGroup, borderAdjustment.left, borderAdjustment.top, currentDimensions.width, currentDimensions.height);\r\n    self.boxHeight = currentDimensions.height;\r\n    lineTopPosition.x = (borderAdjustment.left + (currentDimensions.width / 2));\r\n    lineTopPosition.y = (borderAdjustment.top + currentDimensions.height);\r\n}\r\nfunction updateLine(self, lineGroup, lifelineDescription, depthChanges, style) {\r\n    let overhang = style.getExecutionSpecificationBarOverhang();\r\n    let debugMessage = \"Lifeline \" + self.id + \": depth changes: [\";\r\n    for (let depthChange of depthChanges) {\r\n        debugMessage += \" \" + depthChange[1];\r\n    }\r\n    debugMessage += \" ]\";\r\n    self.log.debug(debugMessage);\r\n    if (depthChanges.length == 1) {\r\n        if (depthChanges[0][1] > 0) {\r\n            SVGUtils_1.SVGUtils.Line(lineGroup, self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0] - overhang);\r\n            SVGUtils_1.SVGUtils.Rectangle(lineGroup, self.lineTopPosition.x - 4, depthChanges[0][0] - overhang, 8, (2 * overhang));\r\n        }\r\n        else {\r\n            SVGUtils_1.SVGUtils.Line(lineGroup, self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0]);\r\n        }\r\n    }\r\n    else if (depthChanges.length > 1) {\r\n        SVGUtils_1.SVGUtils.Line(lineGroup, self.lineTopPosition.x, self.lineTopPosition.y, self.lineTopPosition.x, depthChanges[0][0] - overhang);\r\n        let maxDepth = 0;\r\n        for (let depthChange of depthChanges) {\r\n            maxDepth = Math.max(maxDepth, depthChange[1]);\r\n        }\r\n        let levelStart = [];\r\n        let layers = [];\r\n        for (let i = 0; i <= maxDepth; i++) {\r\n            levelStart.push(-1);\r\n            layers.push(new SVGLayer_1.SVGLayer(self.svg));\r\n        }\r\n        for (let i = 1; i < depthChanges.length; i++) {\r\n            // At each iteration we try to process/draw the previous changes in depth: (i-1)\r\n            // The nesting level of the segment we are currently trying to draw\r\n            let currentNestingLevel = depthChanges[i - 1][1];\r\n            let nextNestingLevel = depthChanges[i][1];\r\n            self.log.trace(\"Lifeline \" + self.id + \": handling depth change \" + i + \" from \"\r\n                + currentNestingLevel + \" to \" + nextNestingLevel);\r\n            if (currentNestingLevel == 0) {\r\n                // Segments outside any execution specification bar can always be drawn immediately since there isn't\r\n                // any nesting possible in that case\r\n                self.log.trace(\"Lifeline \" + self.id + \": drawing line\");\r\n                layers[currentNestingLevel].line(self.lineTopPosition.x, depthChanges[i - 1][0], self.lineTopPosition.x, depthChanges[i][0]);\r\n            }\r\n            else if (nextNestingLevel > currentNestingLevel) {\r\n                // If the depth is increasing we need to hold off on drawing the previous segment since we are going to\r\n                // draw a nested execution specification bar, we store the start of the deferred segment for later use\r\n                self.log.trace(\"Lifeline \" + self.id + \": deferring drawing\");\r\n                levelStart[currentNestingLevel] = depthChanges[i - 1][0];\r\n            }\r\n            else if (nextNestingLevel <= currentNestingLevel) {\r\n                // If the depth stays the same it means we are at the end of the lifeline (remember we eliminate\r\n                // redundant points so the end of the lifeline is is the only case where we'd have two adjacent points\r\n                // of same depth)\r\n                // If the depth is decreasing we can draw the segment since we are at the end of a nested or non-nested\r\n                // execution specification bar\r\n                self.log.trace(\"Lifeline \" + self.id + \": drawing rectangle\");\r\n                let start = depthChanges[i - 1][0];\r\n                if (levelStart[currentNestingLevel] != -1) {\r\n                    start = levelStart[currentNestingLevel];\r\n                }\r\n                let offset = ((currentNestingLevel - 1) * 5);\r\n                SVGUtils_1.SVGUtils.Rectangle(layers[currentNestingLevel], self.lineTopPosition.x - 4 + offset, start - overhang, 8, (depthChanges[i][0] - start + (2 * overhang)));\r\n                levelStart[currentNestingLevel] = -1;\r\n            }\r\n        }\r\n        // If the last change is an increase form 0 to 1 it means we have an isolated message right at the end of the\r\n        // lifeline which is not a destruction occurrence.\r\n        if ((depthChanges[depthChanges.length - 2][1] == 0) &&\r\n            (depthChanges[depthChanges.length - 1][1] > 0)) {\r\n            layers[depthChanges[depthChanges.length - 1][1]]\r\n                .rect(8, (2 * overhang))\r\n                .move(self.lineTopPosition.x - 4, depthChanges[depthChanges.length - 1][0] - overhang);\r\n        }\r\n        // Since we are at the end of the line draw all the segments that are still deferred\r\n        let end = depthChanges[depthChanges.length - 1][0];\r\n        for (let i = 0; i < levelStart.length; i++) {\r\n            if (levelStart[i] != -1) {\r\n                layers[i]\r\n                    .rect(8, (end - levelStart[i] + (2 * overhang)))\r\n                    .move(self.lineTopPosition.x - 4, levelStart[i] - overhang);\r\n            }\r\n        }\r\n        for (let i = 0; i < layers.length; i++) {\r\n            layers[i].write(lineGroup);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Lifeline.ts?");

/***/ }),

/***/ "./src/LifelineLayout.ts":
/*!*******************************!*\
  !*** ./src/LifelineLayout.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n  This class computes and stores the depth levels for the execution\r\n  specifications of the lifeline based on the messages received and\r\n  sent.\r\n*/\r\nclass LifelineLayout {\r\n    /**\r\n      Creates a new LifelineLayout instance.\r\n    */\r\n    constructor() {\r\n        this.depthChanges = [];\r\n    }\r\n    getDepth(y) {\r\n        let result = 0;\r\n        let previous = -1;\r\n        for (let i = 0; ((i < this.depthChanges.length) && (y >= this.depthChanges[i][0])); i++) {\r\n            result = this.depthChanges[i][1];\r\n            if (y > this.depthChanges[i][0]) {\r\n                previous = i;\r\n            }\r\n            else {\r\n                previous = (i - 1);\r\n            }\r\n        }\r\n        if (previous >= 0) {\r\n            result = Math.max(result, this.depthChanges[previous][1]);\r\n        }\r\n        return result;\r\n    }\r\n    dolayout(connectionPoints, adjustmentNeeded) {\r\n        this.depthChanges.length = 0;\r\n        for (let i = 0; i < connectionPoints.length; i++) {\r\n            let connectionPoint = connectionPoints[i];\r\n            switch (connectionPoint.type) {\r\n                case \"synchronous-start\":\r\n                    addCallerOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n                case \"synchronous-end\":\r\n                    addCalleeOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n                case \"return-start\":\r\n                    addReturnOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n                case \"return-end\":\r\n                    addReturnCalleeOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n                case \"creation-start\":\r\n                    addCallerOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n                case \"destruction-end\":\r\n                    if (adjustmentNeeded) {\r\n                        addReturnOccurrence(this.depthChanges, connectionPoint.point.y - 25);\r\n                    }\r\n                    addDestructionOccurrence(this.depthChanges, connectionPoint.point.y);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.LifelineLayout = LifelineLayout;\r\nfunction addCallerOccurrence(depthChanges, y) {\r\n    depthChanges.push([y, 1]);\r\n    concatenateLevels(depthChanges);\r\n}\r\nfunction addCalleeOccurrence(depthChanges, y) {\r\n    if (depthChanges.length == 0) {\r\n        depthChanges.push([y, 1]);\r\n    }\r\n    else {\r\n        depthChanges.push([y, depthChanges[depthChanges.length - 1][1] + 1]);\r\n    }\r\n    concatenateLevels(depthChanges);\r\n}\r\nfunction addReturnOccurrence(depthChanges, y) {\r\n    let newLevel = 0;\r\n    let length = depthChanges.length;\r\n    if (length > 0) {\r\n        newLevel = Math.max(0, (depthChanges[length - 1][1] - 1));\r\n    }\r\n    depthChanges.push([y, newLevel]);\r\n    concatenateLevels(depthChanges);\r\n}\r\nfunction addReturnCalleeOccurrence(depthChanges, y) {\r\n    let length = depthChanges.length;\r\n    if (length == 0) {\r\n        depthChanges.push([y, 1]);\r\n    }\r\n    else {\r\n        depthChanges.push([y, depthChanges[length - 1][1]]);\r\n    }\r\n    concatenateLevels(depthChanges);\r\n}\r\nfunction addDestructionOccurrence(depthChanges, y) {\r\n    depthChanges.push([y, 0]);\r\n}\r\nfunction concatenateLevels(depthChanges) {\r\n    let length = depthChanges.length;\r\n    if (length >= 3) {\r\n        if (depthChanges[length - 3][1] == depthChanges[length - 2][1]) {\r\n            depthChanges[length - 2][0] = depthChanges[length - 1][0];\r\n            depthChanges[length - 2][1] = depthChanges[length - 1][1];\r\n            depthChanges.pop();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/LifelineLayout.ts?");

/***/ }),

/***/ "./src/Log.ts":
/*!********************!*\
  !*** ./src/Log.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * A class used to log diagram events, mostly useful for debugging only.\r\n */\r\nclass Log {\r\n    constructor(level) {\r\n        switch (level) {\r\n            case \"none\":\r\n                this.level = 0;\r\n                break;\r\n            case \"error\":\r\n                this.level = 1;\r\n                break;\r\n            case \"warn\":\r\n                this.level = 2;\r\n                break;\r\n            case \"info\":\r\n                this.level = 3;\r\n                break;\r\n            case \"debug\":\r\n                this.level = 4;\r\n                break;\r\n            case \"trace\":\r\n                this.level = 5;\r\n                break;\r\n        }\r\n    }\r\n    error(message) {\r\n        if (this.level >= 1) {\r\n            console.error(message);\r\n        }\r\n    }\r\n    warn(message) {\r\n        if (this.level >= 2) {\r\n            console.warn(message);\r\n        }\r\n    }\r\n    info(message) {\r\n        if (this.level >= 3) {\r\n            console.log(message);\r\n        }\r\n    }\r\n    debug(message) {\r\n        if (this.level >= 4) {\r\n            console.log(message);\r\n        }\r\n    }\r\n    trace(message) {\r\n        if (this.level >= 5) {\r\n            console.log(message);\r\n        }\r\n    }\r\n}\r\nexports.Log = Log;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Log.ts?");

/***/ }),

/***/ "./src/Metrics.ts":
/*!************************!*\
  !*** ./src/Metrics.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n  A class to collect metrics for performance\r\n  measurements.\r\n*/\r\nclass Metrics {\r\n    constructor() {\r\n    }\r\n}\r\nexports.Metrics = Metrics;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Metrics.ts?");

/***/ }),

/***/ "./src/Node.ts":
/*!*********************!*\
  !*** ./src/Node.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nconst Diagram_1 = __webpack_require__(/*! ./Diagram */ \"./src/Diagram.ts\");\r\n/**\r\n * A node on a deployment diagram.\r\n *\r\n * @extends DiagramElement\r\n */\r\nclass Node extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, idGenerator, nodeDescription, style, errors) {\r\n        super(svg, \"node\" /* Node */, idGenerator.createID(\"node--\" + nodeDescription.name));\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.nodeDescription = nodeDescription;\r\n        this.style = style;\r\n        this.connectionPointsRectangle = null;\r\n    }\r\n    draw() {\r\n        this.update();\r\n        this.layers.getLayer(\"shape\").write();\r\n        this.layers.getLayer(\"text\").write();\r\n    }\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        var nodeGroup = this.shapeLayer.group().addClass(\"UMLNode\");\r\n        let currentDimensions = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        let borderAdjustment = {\r\n            top: this.y + 1,\r\n            left: this.x + 1\r\n        };\r\n        currentDimensions.height = this.style.getTopMargin(\"node\");\r\n        let nodeNameGroup = this.textLayer.group().addClass(\"UMLNodeName\");\r\n        var nodeNameDef = nodeNameGroup.text(this.nodeDescription.name).move(borderAdjustment.left + this.style.getLeftMargin(\"node\"), borderAdjustment.top + currentDimensions.height + 10);\r\n        currentDimensions.width = Math.max(currentDimensions.width, nodeNameDef.bbox().width);\r\n        currentDimensions.height += (nodeNameDef.bbox().height + this.style.getBottomMargin(\"node\"));\r\n        if (currentDimensions.width > nodeNameDef.bbox().width) {\r\n            nodeNameDef.dx((currentDimensions.width - nodeNameDef.bbox().width) / 2);\r\n        }\r\n        // A node can contain a sub-diagram inside it\r\n        if ((this.nodeDescription.elements != null) && (this.nodeDescription.elements.length > 0)) {\r\n            let diagram = new Diagram_1.Diagram(null);\r\n            diagram.createFromJSON(this.layers.svg, this.id, this.nodeDescription, null);\r\n        }\r\n        currentDimensions.width += (this.style.getLeftMargin(\"node\") + this.style.getRightMargin(\"node\"));\r\n        let pt1 = (borderAdjustment.left + 12) + \",\" + borderAdjustment.top;\r\n        let pt2 = (borderAdjustment.left + currentDimensions.width + 10) + \",\" + borderAdjustment.top;\r\n        let pt3 = (borderAdjustment.left + currentDimensions.width) + \",\" + (borderAdjustment.top + 10);\r\n        let pt4 = (borderAdjustment.left) + \",\" + (borderAdjustment.top + 10);\r\n        nodeGroup.polygon(pt1 + \" \" + pt2 + \" \" + pt3 + \" \" + pt4);\r\n        let pt5 = (borderAdjustment.left + currentDimensions.width) + \",\" + (borderAdjustment.top + currentDimensions.height + 10);\r\n        let pt6 = (borderAdjustment.left + currentDimensions.width + 10) + \",\" + (borderAdjustment.top + currentDimensions.height - 1);\r\n        nodeGroup.polygon(pt2 + \" \" + pt3 + \" \" + pt5 + \" \" + pt6);\r\n        let rect = nodeGroup.rect(currentDimensions.width, currentDimensions.height).move(borderAdjustment.left, borderAdjustment.top + 10);\r\n        this.connectionPointsRectangle = rect.bbox();\r\n        this.connectionPointsRectangle.cy -= 5;\r\n        this.connectionPointsRectangle.width += 5;\r\n    }\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle;\r\n    }\r\n}\r\nexports.Node = Node;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Node.ts?");

/***/ }),

/***/ "./src/Note.ts":
/*!*********************!*\
  !*** ./src/Note.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\n/**\r\n  A note on a UML diagram.\r\n\r\n  @extends DiagramElement\r\n*/\r\nclass Note extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, id, noteDescription, style) {\r\n        super(svg, null, null);\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.noteDescription = noteDescription;\r\n        this.style = style;\r\n    }\r\n    update() {\r\n        this.uptodate = true;\r\n    }\r\n}\r\nexports.Note = Note;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Note.ts?");

/***/ }),

/***/ "./src/SVGLayer.ts":
/*!*************************!*\
  !*** ./src/SVGLayer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * <p>\r\n *   The SVG specification has no concept of layers. The order in which elements are added to the image dictate which\r\n *   ones will be shown over the others. This is impractical so this class attempts to provide a workaround.\r\n * </p>\r\n *\r\n * <p>\r\n *   Drawing will be first done on several layers. The elements in each of the layers will then be added to the SVG\r\n *   document layer per layer.\r\n * </p>\r\n*/\r\nclass SVGLayer {\r\n    /**\r\n     * Creates a new SVGLayer instance.\r\n     *\r\n     * @param {SVG} svg - The root SVG document.\r\n     */\r\n    constructor(svg) {\r\n        this.svg = svg;\r\n        this.defs = [];\r\n    }\r\n    /**\r\n     * Adds a group to the layer.\r\n     *\r\n     * @returns {SVG.G} An SVG.G element as decribed in {@link http://svgjs.com/parents/#svg-g}\r\n     */\r\n    group(id) {\r\n        let groupDef = this.svg.defs().group();\r\n        if (id) {\r\n            groupDef.id(id);\r\n        }\r\n        else {\r\n            // By default SVG.js will assign an id to every element but setting it to null will remove it\r\n            groupDef.id(null);\r\n        }\r\n        this.defs.push(groupDef);\r\n        return groupDef;\r\n    }\r\n    circle(radius) {\r\n        let circleDef = this.svg.defs().circle(radius);\r\n        circleDef.id(null);\r\n        this.defs.push(circleDef);\r\n        return circleDef;\r\n    }\r\n    /**\r\n     * Adds a line to the layer.\r\n     *\r\n     * @returns {SVG.Line} An SVG.Line element as decribed in {@link http://svgjs.com/elements/#svg-line}\r\n     */\r\n    line(x1, y1, x2, y2) {\r\n        let lineDef = this.svg.defs().line(x1, y1, x2, y2);\r\n        lineDef.id(null);\r\n        this.defs.push(lineDef);\r\n        return lineDef;\r\n    }\r\n    polygon(description) {\r\n        let polygonDef = this.svg.defs().polygon(description);\r\n        polygonDef.id(null);\r\n        this.defs.push(polygonDef);\r\n        return polygonDef;\r\n    }\r\n    /**\r\n      Adds a rectangle to the layer.\r\n\r\n      @returns {SVG.Rect} An SVG.Rect element as decribed in {@link http://svgjs.com/elements/#svg-rect}\r\n    */\r\n    rect(width, height) {\r\n        let rectDef = this.svg.defs().rect(width, height);\r\n        rectDef.id(null);\r\n        this.defs.push(rectDef);\r\n        return rectDef;\r\n    }\r\n    /**\r\n      Adds a text element to the layer.\r\n\r\n      @returns {SVG.Text} An SVG.Text element as decribed in {@link http://svgjs.com/elements/#svg-text}\r\n    */\r\n    text(str) {\r\n        let textDef = this.svg.defs().text(str);\r\n        textDef.id(null);\r\n        this.defs.push(textDef);\r\n        return textDef;\r\n    }\r\n    /**\r\n     * Writes the layer to the SVG document. This should be the final action performed on the layer. In the current\r\n     * implementation there is no way to undo the write.\r\n     */\r\n    write(container) {\r\n        let self = this;\r\n        if (container == null) {\r\n            container = self.svg;\r\n        }\r\n        self.defs.forEach(function (element) {\r\n            // This will also remove the element from the defs section\r\n            container.add(element);\r\n        });\r\n    }\r\n    /**\r\n      Merges the contents of another layer into this layer.\r\n      The other layer should not be used afterwards.\r\n\r\n      @param {SVGLayer} layer - The contents of this layer will be merged\r\n        into this one.\r\n    */\r\n    merge(layer) {\r\n        this.defs = this.defs.concat(layer.defs);\r\n    }\r\n    /**\r\n      Remove all contents of the layer. Note that this doesn't\r\n      remove elements that have been written to the SVG document\r\n      already.\r\n    */\r\n    clear() {\r\n        let self = this;\r\n        self.defs.forEach(function (def) {\r\n            def.remove();\r\n        });\r\n        self.defs.length = 0;\r\n    }\r\n}\r\nexports.SVGLayer = SVGLayer;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SVGLayer.ts?");

/***/ }),

/***/ "./src/SVGLayerSet.ts":
/*!****************************!*\
  !*** ./src/SVGLayerSet.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGLayer_1 = __webpack_require__(/*! ./SVGLayer */ \"./src/SVGLayer.ts\");\r\n/**\r\n  <p>\r\n    A set of layers.\r\n  </p>\r\n*/\r\nclass SVGLayerSet {\r\n    /**\r\n      Creates a new SVGLayerSet instance.\r\n\r\n      @param {SVG} svg - The root SVG document.\r\n    */\r\n    constructor(svg) {\r\n        this.svg = svg;\r\n        this.layers = {};\r\n    }\r\n    /**\r\n      Gets a layer.\r\n\r\n      @param {string} name - The name of the layer.\r\n      @returns {SVGLayer|null} The layer or null if no layer\r\n        with such name exists.\r\n    */\r\n    getLayer(name) {\r\n        return this.layers[name];\r\n    }\r\n    /**\r\n      Creates a new layer.\r\n\r\n      @param {string} name - The name of the layer.\r\n      @returns {SVGLayer} The new layer.\r\n    */\r\n    createLayer(name) {\r\n        let newLayer = new SVGLayer_1.SVGLayer(this.svg);\r\n        this.layers[name] = newLayer;\r\n        return newLayer;\r\n    }\r\n    /**\r\n      Merge another set into this one. Layers\r\n      with the same name will be merged together\r\n      with the elements of the set given as argument\r\n      being appended.\r\n\r\n      @param {SVGLayerSet} layerSet - The other layer set.\r\n    */\r\n    merge(layerSet) {\r\n        let self = this;\r\n        let keys = Object.keys(self.layers);\r\n        keys.forEach(function (key) {\r\n            self.layers[key].merge(layerSet.layers[key]);\r\n        });\r\n    }\r\n    /**\r\n      Calls {@link SVGLayer#clear} on each layer in the set.\r\n    */\r\n    clearEachLayer() {\r\n        let self = this;\r\n        let keys = Object.keys(self.layers);\r\n        keys.forEach(function (key) {\r\n            self.layers[key].clear();\r\n        });\r\n    }\r\n}\r\nexports.SVGLayerSet = SVGLayerSet;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SVGLayerSet.ts?");

/***/ }),

/***/ "./src/SVGUtils.ts":
/*!*************************!*\
  !*** ./src/SVGUtils.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass SVGUtils {\r\n    static Group(parent) {\r\n        let group = parent.group();\r\n        group.id(null);\r\n        return group;\r\n    }\r\n    static Rectangle(parent, left, top, width, height) {\r\n        let rect = parent.rect(width, height).move(left, top);\r\n        rect.id(null);\r\n        return rect;\r\n    }\r\n    static Line(parent, x1, y1, x2, y2) {\r\n        let line = parent.line(x1, y1, x2, y2);\r\n        line.id(null);\r\n        return line;\r\n    }\r\n    static Polygon(parent, description) {\r\n        let polygon = parent.polygon(description);\r\n        polygon.id(null);\r\n        return polygon;\r\n    }\r\n    static Text(parent, left, top, str) {\r\n        let text = parent.text(str).move(left, top);\r\n        text.id(null);\r\n        return text;\r\n    }\r\n}\r\nexports.SVGUtils = SVGUtils;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SVGUtils.ts?");

/***/ }),

/***/ "./src/Settings.ts":
/*!*************************!*\
  !*** ./src/Settings.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Diagram settings.\r\n *\r\n * @property {int} width - The width of the diagram in pixels.\r\n * @property {height} height - The height of the diagram in pixels.\r\n * @property {boolean} debug - If debug is true then additional checks and logging will be performed. This is false by\r\n *     default so that diagrams are displayed as well as possible regardless of errors. It is recommended to enable\r\n *     debug mode when updating a diagram and set it back to false afterwards.\r\n */\r\nclass Settings {\r\n    /**\r\n      Creates a new Settings instance with each property\r\n      having a default value or the value specified in\r\n      the jsonSettings argument.\r\n      @param {json=} jsonSettings - The initial settings.\r\n      @param {int} [jsonSettings.width=600] - The width of the diagram.\r\n      @param {int} [jsonSettings.height=200] - The height of the diagram.\r\n      @param {boolean} [jsonSettings.debug=false] - Debug mode.\r\n    */\r\n    constructor(jsonSettings) {\r\n        this.width = 600;\r\n        this.height = 200;\r\n        this.canMove = false;\r\n        this.canResize = false;\r\n        this.logLevel = \"none\";\r\n        this.buildType = 1 /* RELEASE */;\r\n        if (jsonSettings) {\r\n            if (jsonSettings.width) {\r\n                this.width = jsonSettings.width;\r\n            }\r\n            if (jsonSettings.height) {\r\n                this.height = jsonSettings.height;\r\n            }\r\n            if (jsonSettings.interactive) {\r\n                if (jsonSettings.interactive.canMove) {\r\n                    this.canMove = jsonSettings.interactive.canMove;\r\n                }\r\n            }\r\n            if (jsonSettings.logLevel != null) {\r\n                this.logLevel = jsonSettings.logLevel;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Settings = Settings;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Settings.ts?");

/***/ }),

/***/ "./src/SocketConnector.ts":
/*!********************************!*\
  !*** ./src/SocketConnector.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGLayerSet_1 = __webpack_require__(/*! ./SVGLayerSet */ \"./src/SVGLayerSet.ts\");\r\nvar textDef = Symbol();\r\n/**\r\n  A socket connector to represent a dependency for a\r\n  component.\r\n*/\r\nclass SocketConnector {\r\n    constructor(svg, component, name) {\r\n        this.svg = svg;\r\n        this.layers = new SVGLayerSet_1.SVGLayerSet(svg);\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.uptodate = false;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.component = component;\r\n        this.name = name;\r\n        this.textGroup = this.textLayer.group();\r\n        this[textDef] = this.textGroup.text(this.name).move(0, 0);\r\n        this.width = this[textDef].bbox().width + 5;\r\n    }\r\n    getLayers() {\r\n        if (!this.uptodate) {\r\n            this.update();\r\n        }\r\n        return this.layers;\r\n    }\r\n    // Move the connector so that the top left\r\n    // corner of the bounding box is at position\r\n    // (x, y)\r\n    move(x, y) {\r\n        this.uptodate = false;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // Move the connector so that its connection\r\n    // point is at position (x, y)\r\n    moveConnectionPoint(x, y) {\r\n        this.uptodate = false;\r\n        let connectorOffsetY = this[textDef].bbox().height + 6;\r\n        y -= connectorOffsetY;\r\n        this.move(x, y);\r\n    }\r\n    update() {\r\n        this.shapeLayer.clear();\r\n        this[textDef].move(this.x + 5, this.y);\r\n        let lineGroup = this.shapeLayer.group().addClass(\"UMLComponent\");\r\n        lineGroup.line(this.x, this.y + this[textDef].bbox().height + 8, this.x + (this.width / 2), this.y + this[textDef].bbox().height + 8);\r\n        let clippath = this.svg.clip();\r\n        clippath.rect(10, 17).move(this.x + (this.width / 2) - 1, this.y + this[textDef].bbox().height, 0);\r\n        lineGroup.circle(15).move(this.x + (this.width / 2), this.y + this[textDef].bbox().height + 1).clipWith(clippath);\r\n        this.uptodate = true;\r\n    }\r\n    getAssemblyConnectionPoint() {\r\n        return { x: (this.x + (this.width / 2) - 1 + 10), y: this.y + this[textDef].bbox().height + 8 };\r\n    }\r\n}\r\nexports.SocketConnector = SocketConnector;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/SocketConnector.ts?");

/***/ }),

/***/ "./src/Style.ts":
/*!**********************!*\
  !*** ./src/Style.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Style settings. */\r\nclass Style {\r\n    constructor() {\r\n        this.style = new Map();\r\n        this.style.set(\"defaults\", {\r\n            \"margin-left\": 12,\r\n            \"margin-right\": 12,\r\n            \"margin-top\": 9,\r\n            \"margin-bottom\": 9\r\n        });\r\n        this.style.set(\"class-template\" /* ClassTemplate */, {\r\n            \"margin-right\": 15,\r\n            \"margin-top\": 12\r\n        });\r\n        this.style.set(\"class-template__parameters-compartment\" /* ClassTemplate_ParametersCompartment */, {\r\n            \"margin-left\": 8,\r\n            \"margin-right\": 8,\r\n            \"margin-top\": 4,\r\n            \"margin-bottom\": 4\r\n        });\r\n        this.style.set(\"lifeline\", {\r\n            \"execution-specification-bar-width\": 8,\r\n            \"execution-specification-bar-overhang\": 5,\r\n            \"execution-specification-bar-margin\": 15\r\n        });\r\n    }\r\n    getTopMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-top\");\r\n    }\r\n    getBottomMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-bottom\");\r\n    }\r\n    getLeftMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-left\");\r\n    }\r\n    getRightMargin(element) {\r\n        return this.getValueOrDefault(this, element, \"margin-right\");\r\n    }\r\n    getExecutionSpecificationBarWidth() {\r\n        return this.style.get(\"lifeline\")[\"execution-specification-bar-width\"];\r\n    }\r\n    getExecutionSpecificationBarOverhang() {\r\n        return this.style.get(\"lifeline\")[\"execution-specification-bar-overhang\"];\r\n    }\r\n    getExecutionSpecificationBarMargin() {\r\n        return this.style.get(\"lifeline\")[\"execution-specification-bar-margin\"];\r\n    }\r\n    getValueOrDefault(self, element, style) {\r\n        if (self.style.get(element) && self.style.get(element)[style]) {\r\n            return self.style.get(element)[style];\r\n        }\r\n        else {\r\n            return self.style.get(\"defaults\")[style];\r\n        }\r\n    }\r\n}\r\nexports.Style = Style;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/Style.ts?");

/***/ }),

/***/ "./src/UseCase.ts":
/*!************************!*\
  !*** ./src/UseCase.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\n/**\r\n * A use case on a use case diagram.\r\n *\r\n * @extends DiagramElement\r\n */\r\nclass UseCase extends DiagramElement_1.DiagramElement {\r\n    constructor(svg, id, useCaseDescription, errors) {\r\n        super(svg, \"usecase\", id);\r\n        this.errors = errors;\r\n        this.shapeLayer = this.layers.createLayer(\"shape\");\r\n        this.textLayer = this.layers.createLayer(\"text\");\r\n        this.useCaseDescription = useCaseDescription;\r\n        this.connectionPointsRectangle = null;\r\n    }\r\n    draw() {\r\n        this.update();\r\n        this.layers.getLayer(\"shape\").write();\r\n        this.layers.getLayer(\"text\").write();\r\n    }\r\n    createConnectionPoint(svg) {\r\n        let newPoint = new ConnectionPoint_1.ConnectionPoint(svg, this, ConnectionPointPosition_1.ConnectionPointPosition.BottomCenter, this.errors);\r\n        return newPoint;\r\n    }\r\n    doUpdate() {\r\n        let borderAdjustment = {\r\n            top: this.y,\r\n            left: this.x\r\n        };\r\n        let shapeGroup = this.shapeLayer.group().addClass(\"UMLUseCase\");\r\n        let textGroup = this.textLayer.group();\r\n        let textDef = textGroup.text(this.useCaseDescription.title);\r\n        let ellipse = shapeGroup.ellipse(1.2 * textDef.bbox().width, 3 * textDef.bbox().height).move(borderAdjustment.left + 1, borderAdjustment.top + 1);\r\n        textDef.move(borderAdjustment.left + 1 + 0.1 * textDef.bbox().width, borderAdjustment.top + 1 + textDef.bbox().height);\r\n        this.connectionPointsRectangle = ellipse.bbox();\r\n    }\r\n    doGetConnectionPointsRectangle() {\r\n        return this.connectionPointsRectangle;\r\n    }\r\n}\r\nexports.UseCase = UseCase;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/UseCase.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Copyright (c) 2020 Xavier Leclercq\r\n    Released under the MIT License\r\n    See https://github.com/CodeSmithyIDE/UMLWebWidget/blob/master/LICENSE.txt\r\n*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Errors_1 = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\r\nexports.Errors = Errors_1.Errors;\r\nexports.UMLWebWidgetError = Errors_1.UMLWebWidgetError;\r\nconst IDGenerator_1 = __webpack_require__(/*! ./IDGenerator */ \"./src/IDGenerator.ts\");\r\nexports.IDGenerator = IDGenerator_1.IDGenerator;\r\nconst Settings_1 = __webpack_require__(/*! ./Settings */ \"./src/Settings.ts\");\r\nexports.Settings = Settings_1.Settings;\r\nconst Style_1 = __webpack_require__(/*! ./Style */ \"./src/Style.ts\");\r\nexports.Style = Style_1.Style;\r\nconst Diagram_1 = __webpack_require__(/*! ./Diagram */ \"./src/Diagram.ts\");\r\nexports.Diagram = Diagram_1.Diagram;\r\nconst ConnectionPoint_1 = __webpack_require__(/*! ./ConnectionPoint */ \"./src/ConnectionPoint.ts\");\r\nexports.ConnectionPoint = ConnectionPoint_1.ConnectionPoint;\r\nconst ConnectionPointPosition_1 = __webpack_require__(/*! ./ConnectionPointPosition */ \"./src/ConnectionPointPosition.ts\");\r\nexports.ConnectionPointPosition = ConnectionPointPosition_1.ConnectionPointPosition;\r\nconst DiagramElement_1 = __webpack_require__(/*! ./DiagramElement */ \"./src/DiagramElement.ts\");\r\nexports.DiagramElement = DiagramElement_1.DiagramElement;\r\nconst Connector_1 = __webpack_require__(/*! ./Connector */ \"./src/Connector.ts\");\r\nexports.Connector = Connector_1.Connector;\r\nconst LayoutManager_1 = __webpack_require__(/*! ./LayoutManager */ \"./src/LayoutManager.ts\");\r\nexports.LayoutManager = LayoutManager_1.LayoutManager;\r\nconst LifelineLayout_1 = __webpack_require__(/*! ./LifelineLayout */ \"./src/LifelineLayout.ts\");\r\nexports.LifelineLayout = LifelineLayout_1.LifelineLayout;\r\nconst ClassBox_1 = __webpack_require__(/*! ./ClassBox */ \"./src/ClassBox.ts\");\r\nexports.ClassBox = ClassBox_1.ClassBox;\r\nconst ClassTemplate_1 = __webpack_require__(/*! ./ClassTemplate */ \"./src/ClassTemplate.ts\");\r\nexports.ClassTemplate = ClassTemplate_1.ClassTemplate;\r\nconst Lifeline_1 = __webpack_require__(/*! ./Lifeline */ \"./src/Lifeline.ts\");\r\nexports.Lifeline = Lifeline_1.Lifeline;\r\nconst Actor_1 = __webpack_require__(/*! ./Actor */ \"./src/Actor.ts\");\r\nexports.Actor = Actor_1.Actor;\r\nconst UseCase_1 = __webpack_require__(/*! ./UseCase */ \"./src/UseCase.ts\");\r\nexports.UseCase = UseCase_1.UseCase;\r\nconst Component_1 = __webpack_require__(/*! ./Component */ \"./src/Component.ts\");\r\nexports.Component = Component_1.Component;\r\nconst Node_1 = __webpack_require__(/*! ./Node */ \"./src/Node.ts\");\r\nexports.Node = Node_1.Node;\r\nconst Note_1 = __webpack_require__(/*! ./Note */ \"./src/Note.ts\");\r\nexports.Note = Note_1.Note;\r\nconst SVGLayer_1 = __webpack_require__(/*! ./SVGLayer */ \"./src/SVGLayer.ts\");\r\nexports.SVGLayer = SVGLayer_1.SVGLayer;\r\nconst SVGLayerSet_1 = __webpack_require__(/*! ./SVGLayerSet */ \"./src/SVGLayerSet.ts\");\r\nexports.SVGLayerSet = SVGLayerSet_1.SVGLayerSet;\r\nconst Log_1 = __webpack_require__(/*! ./Log */ \"./src/Log.ts\");\r\nexports.Log = Log_1.Log;\r\nconst Metrics_1 = __webpack_require__(/*! ./Metrics */ \"./src/Metrics.ts\");\r\nexports.Metrics = Metrics_1.Metrics;\r\n\n\n//# sourceURL=webpack://CodeSmithyUMLWebWidget/./src/index.ts?");

/***/ })

/******/ });
});